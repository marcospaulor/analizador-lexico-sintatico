Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    FALSE
    FOR
    GREATER_THAN
    GREATER_THAN_OR_EQUAL
    LESS_THAN
    LESS_THAN_OR_EQUAL
    MAIN
    NOT_EQUALS
    OR
    PRIVATE
    PUBLIC
    RETURN
    STATIC
    THIS
    TRUE
    VOID

Grammar

Rule 0     S' -> program
Rule 1     program -> body_program
Rule 2     body_program -> class_decl body_program
Rule 3     body_program -> import_decl body_program
Rule 4     body_program -> var_decl body_program
Rule 5     body_program -> empty
Rule 6     class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE
Rule 7     class_decl -> CLASS ID LBRACE body RBRACE
Rule 8     import_decl -> IMPORT ID DOT ID SEMICOLON
Rule 9     var_decl -> type ID SEMICOLON
Rule 10    var_decl -> type ID EQUAL expr SEMICOLON
Rule 11    method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE
Rule 12    params -> type ID
Rule 13    params -> type ID COMMA params
Rule 14    params -> empty
Rule 15    body -> var_decl body
Rule 16    body -> method_decl body
Rule 17    body -> statement body
Rule 18    body -> empty
Rule 19    type -> INT
Rule 20    type -> BOOLEAN
Rule 21    type -> STRING
Rule 22    type -> ID
Rule 23    type -> type LSQUARE RSQUARE
Rule 24    expr -> expr PLUS term
Rule 25    expr -> expr MINUS term
Rule 26    expr -> term
Rule 27    term -> term TIMES factor
Rule 28    term -> term DIVIDE factor
Rule 29    term -> factor
Rule 30    factor -> MINUS factor
Rule 31    factor -> NOT factor
Rule 32    factor -> INT_LITERAL
Rule 33    factor -> BOOLEAN_LITERAL
Rule 34    factor -> STRING_LITERAL
Rule 35    factor -> ID
Rule 36    factor -> ID LSQUARE expr RSQUARE
Rule 37    factor -> ID DOT ID
Rule 38    factor -> ID DOT ID LPAREN args RPAREN
Rule 39    factor -> ID LPAREN args RPAREN
Rule 40    factor -> NEW ID LPAREN RPAREN
Rule 41    factor -> NEW INT LSQUARE expr RSQUARE
Rule 42    factor -> LPAREN expr RPAREN
Rule 43    args -> expr
Rule 44    args -> expr COMMA args
Rule 45    args -> empty
Rule 46    statement -> LBRACE body RBRACE
Rule 47    statement -> IF LPAREN expr RPAREN statement ELSE statement
Rule 48    statement -> IF LPAREN expr RPAREN statement
Rule 49    statement -> WHILE LPAREN expr RPAREN statement
Rule 50    statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
Rule 51    statement -> ID EQUALS expr SEMICOLON
Rule 52    statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
Rule 53    empty -> <empty>

Terminals, with rules where they appear

AND                  : 
BOOLEAN              : 20
BOOLEAN_LITERAL      : 33
CLASS                : 6 7
COMMA                : 13 44
DIVIDE               : 28
DOT                  : 8 37 38 50 50
ELSE                 : 47
EQUAL                : 10
EQUALS               : 51 52
EXTENDS              : 6
FALSE                : 
FOR                  : 
GREATER_THAN         : 
GREATER_THAN_OR_EQUAL : 
ID                   : 6 6 7 8 8 9 10 11 12 13 22 35 36 37 37 38 38 39 40 51 52
IF                   : 47 48
IMPORT               : 8
INT                  : 19 41
INT_LITERAL          : 32
LBRACE               : 6 7 11 46
LESS_THAN            : 
LESS_THAN_OR_EQUAL   : 
LPAREN               : 11 38 39 40 42 47 48 49 50
LSQUARE              : 23 36 41 52
MAIN                 : 
MINUS                : 25 30
NEW                  : 40 41
NOT                  : 31
NOT_EQUALS           : 
OR                   : 
OUT                  : 50
PLUS                 : 24
PRINTLN              : 50
PRIVATE              : 
PUBLIC               : 
RBRACE               : 6 7 11 46
RETURN               : 
RPAREN               : 11 38 39 40 42 47 48 49 50
RSQUARE              : 23 36 41 52
SEMICOLON            : 8 9 10 50 51 52
STATIC               : 
STRING               : 21
STRING_LITERAL       : 34
SYSTEM               : 50
THIS                 : 
TIMES                : 27
TRUE                 : 
VOID                 : 
WHILE                : 49
error                : 

Nonterminals, with rules where they appear

args                 : 38 39 44
body                 : 6 7 11 15 16 17 46
body_program         : 1 2 3 4
class_decl           : 2
empty                : 5 14 18 45
expr                 : 10 24 25 36 41 42 43 44 47 48 49 50 51 52 52
factor               : 27 28 29 30 31
import_decl          : 3
method_decl          : 16
params               : 11 13
program              : 0
statement            : 17 47 47 48 49
term                 : 24 25 26 27 28
type                 : 9 10 11 12 13 23
var_decl             : 4 15

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . body_program
    (2) body_program -> . class_decl body_program
    (3) body_program -> . import_decl body_program
    (4) body_program -> . var_decl body_program
    (5) body_program -> . empty
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> . CLASS ID LBRACE body RBRACE
    (8) import_decl -> . IMPORT ID DOT ID SEMICOLON
    (9) var_decl -> . type ID SEMICOLON
    (10) var_decl -> . type ID EQUAL expr SEMICOLON
    (53) empty -> .
    (19) type -> . INT
    (20) type -> . BOOLEAN
    (21) type -> . STRING
    (22) type -> . ID
    (23) type -> . type LSQUARE RSQUARE

    CLASS           shift and go to state 7
    IMPORT          shift and go to state 9
    $end            reduce using rule 53 (empty -> .)
    INT             shift and go to state 11
    BOOLEAN         shift and go to state 12
    STRING          shift and go to state 13
    ID              shift and go to state 8

    program                        shift and go to state 1
    body_program                   shift and go to state 2
    class_decl                     shift and go to state 3
    import_decl                    shift and go to state 4
    var_decl                       shift and go to state 5
    empty                          shift and go to state 6
    type                           shift and go to state 10

state 1

    (0) S' -> program .



state 2

    (1) program -> body_program .

    $end            reduce using rule 1 (program -> body_program .)


state 3

    (2) body_program -> class_decl . body_program
    (2) body_program -> . class_decl body_program
    (3) body_program -> . import_decl body_program
    (4) body_program -> . var_decl body_program
    (5) body_program -> . empty
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> . CLASS ID LBRACE body RBRACE
    (8) import_decl -> . IMPORT ID DOT ID SEMICOLON
    (9) var_decl -> . type ID SEMICOLON
    (10) var_decl -> . type ID EQUAL expr SEMICOLON
    (53) empty -> .
    (19) type -> . INT
    (20) type -> . BOOLEAN
    (21) type -> . STRING
    (22) type -> . ID
    (23) type -> . type LSQUARE RSQUARE

    CLASS           shift and go to state 7
    IMPORT          shift and go to state 9
    $end            reduce using rule 53 (empty -> .)
    INT             shift and go to state 11
    BOOLEAN         shift and go to state 12
    STRING          shift and go to state 13
    ID              shift and go to state 8

    class_decl                     shift and go to state 3
    body_program                   shift and go to state 14
    import_decl                    shift and go to state 4
    var_decl                       shift and go to state 5
    empty                          shift and go to state 6
    type                           shift and go to state 10

state 4

    (3) body_program -> import_decl . body_program
    (2) body_program -> . class_decl body_program
    (3) body_program -> . import_decl body_program
    (4) body_program -> . var_decl body_program
    (5) body_program -> . empty
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> . CLASS ID LBRACE body RBRACE
    (8) import_decl -> . IMPORT ID DOT ID SEMICOLON
    (9) var_decl -> . type ID SEMICOLON
    (10) var_decl -> . type ID EQUAL expr SEMICOLON
    (53) empty -> .
    (19) type -> . INT
    (20) type -> . BOOLEAN
    (21) type -> . STRING
    (22) type -> . ID
    (23) type -> . type LSQUARE RSQUARE

    CLASS           shift and go to state 7
    IMPORT          shift and go to state 9
    $end            reduce using rule 53 (empty -> .)
    INT             shift and go to state 11
    BOOLEAN         shift and go to state 12
    STRING          shift and go to state 13
    ID              shift and go to state 8

    import_decl                    shift and go to state 4
    body_program                   shift and go to state 15
    class_decl                     shift and go to state 3
    var_decl                       shift and go to state 5
    empty                          shift and go to state 6
    type                           shift and go to state 10

state 5

    (4) body_program -> var_decl . body_program
    (2) body_program -> . class_decl body_program
    (3) body_program -> . import_decl body_program
    (4) body_program -> . var_decl body_program
    (5) body_program -> . empty
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> . CLASS ID LBRACE body RBRACE
    (8) import_decl -> . IMPORT ID DOT ID SEMICOLON
    (9) var_decl -> . type ID SEMICOLON
    (10) var_decl -> . type ID EQUAL expr SEMICOLON
    (53) empty -> .
    (19) type -> . INT
    (20) type -> . BOOLEAN
    (21) type -> . STRING
    (22) type -> . ID
    (23) type -> . type LSQUARE RSQUARE

    CLASS           shift and go to state 7
    IMPORT          shift and go to state 9
    $end            reduce using rule 53 (empty -> .)
    INT             shift and go to state 11
    BOOLEAN         shift and go to state 12
    STRING          shift and go to state 13
    ID              shift and go to state 8

    var_decl                       shift and go to state 5
    body_program                   shift and go to state 16
    class_decl                     shift and go to state 3
    import_decl                    shift and go to state 4
    empty                          shift and go to state 6
    type                           shift and go to state 10

state 6

    (5) body_program -> empty .

    $end            reduce using rule 5 (body_program -> empty .)


state 7

    (6) class_decl -> CLASS . ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> CLASS . ID LBRACE body RBRACE

    ID              shift and go to state 17


state 8

    (22) type -> ID .

    ID              reduce using rule 22 (type -> ID .)
    LSQUARE         reduce using rule 22 (type -> ID .)


state 9

    (8) import_decl -> IMPORT . ID DOT ID SEMICOLON

    ID              shift and go to state 18


state 10

    (9) var_decl -> type . ID SEMICOLON
    (10) var_decl -> type . ID EQUAL expr SEMICOLON
    (23) type -> type . LSQUARE RSQUARE

    ID              shift and go to state 19
    LSQUARE         shift and go to state 20


state 11

    (19) type -> INT .

    ID              reduce using rule 19 (type -> INT .)
    LSQUARE         reduce using rule 19 (type -> INT .)


state 12

    (20) type -> BOOLEAN .

    ID              reduce using rule 20 (type -> BOOLEAN .)
    LSQUARE         reduce using rule 20 (type -> BOOLEAN .)


state 13

    (21) type -> STRING .

    ID              reduce using rule 21 (type -> STRING .)
    LSQUARE         reduce using rule 21 (type -> STRING .)


state 14

    (2) body_program -> class_decl body_program .

    $end            reduce using rule 2 (body_program -> class_decl body_program .)


state 15

    (3) body_program -> import_decl body_program .

    $end            reduce using rule 3 (body_program -> import_decl body_program .)


state 16

    (4) body_program -> var_decl body_program .

    $end            reduce using rule 4 (body_program -> var_decl body_program .)


state 17

    (6) class_decl -> CLASS ID . EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> CLASS ID . LBRACE body RBRACE

    EXTENDS         shift and go to state 21
    LBRACE          shift and go to state 22


state 18

    (8) import_decl -> IMPORT ID . DOT ID SEMICOLON

    DOT             shift and go to state 23


state 19

    (9) var_decl -> type ID . SEMICOLON
    (10) var_decl -> type ID . EQUAL expr SEMICOLON

    SEMICOLON       shift and go to state 24
    EQUAL           shift and go to state 25


state 20

    (23) type -> type LSQUARE . RSQUARE

    RSQUARE         shift and go to state 26


state 21

    (6) class_decl -> CLASS ID EXTENDS . ID LBRACE body RBRACE

    ID              shift and go to state 27


state 22

    (7) class_decl -> CLASS ID LBRACE . body RBRACE
    (15) body -> . var_decl body
    (16) body -> . method_decl body
    (17) body -> . statement body
    (18) body -> . empty
    (9) var_decl -> . type ID SEMICOLON
    (10) var_decl -> . type ID EQUAL expr SEMICOLON
    (11) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (46) statement -> . LBRACE body RBRACE
    (47) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (48) statement -> . IF LPAREN expr RPAREN statement
    (49) statement -> . WHILE LPAREN expr RPAREN statement
    (50) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (51) statement -> . ID EQUALS expr SEMICOLON
    (52) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (53) empty -> .
    (19) type -> . INT
    (20) type -> . BOOLEAN
    (21) type -> . STRING
    (22) type -> . ID
    (23) type -> . type LSQUARE RSQUARE

    LBRACE          shift and go to state 29
    IF              shift and go to state 36
    WHILE           shift and go to state 37
    SYSTEM          shift and go to state 38
    ID              shift and go to state 28
    RBRACE          reduce using rule 53 (empty -> .)
    INT             shift and go to state 11
    BOOLEAN         shift and go to state 12
    STRING          shift and go to state 13

    body                           shift and go to state 30
    var_decl                       shift and go to state 31
    method_decl                    shift and go to state 32
    statement                      shift and go to state 33
    empty                          shift and go to state 34
    type                           shift and go to state 35

state 23

    (8) import_decl -> IMPORT ID DOT . ID SEMICOLON

    ID              shift and go to state 39


state 24

    (9) var_decl -> type ID SEMICOLON .

    CLASS           reduce using rule 9 (var_decl -> type ID SEMICOLON .)
    IMPORT          reduce using rule 9 (var_decl -> type ID SEMICOLON .)
    INT             reduce using rule 9 (var_decl -> type ID SEMICOLON .)
    BOOLEAN         reduce using rule 9 (var_decl -> type ID SEMICOLON .)
    STRING          reduce using rule 9 (var_decl -> type ID SEMICOLON .)
    ID              reduce using rule 9 (var_decl -> type ID SEMICOLON .)
    $end            reduce using rule 9 (var_decl -> type ID SEMICOLON .)
    LBRACE          reduce using rule 9 (var_decl -> type ID SEMICOLON .)
    IF              reduce using rule 9 (var_decl -> type ID SEMICOLON .)
    WHILE           reduce using rule 9 (var_decl -> type ID SEMICOLON .)
    SYSTEM          reduce using rule 9 (var_decl -> type ID SEMICOLON .)
    RBRACE          reduce using rule 9 (var_decl -> type ID SEMICOLON .)


state 25

    (10) var_decl -> type ID EQUAL . expr SEMICOLON
    (24) expr -> . expr PLUS term
    (25) expr -> . expr MINUS term
    (26) expr -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    expr                           shift and go to state 41
    term                           shift and go to state 42
    factor                         shift and go to state 44

state 26

    (23) type -> type LSQUARE RSQUARE .

    ID              reduce using rule 23 (type -> type LSQUARE RSQUARE .)
    LSQUARE         reduce using rule 23 (type -> type LSQUARE RSQUARE .)


state 27

    (6) class_decl -> CLASS ID EXTENDS ID . LBRACE body RBRACE

    LBRACE          shift and go to state 51


state 28

    (51) statement -> ID . EQUALS expr SEMICOLON
    (52) statement -> ID . LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (22) type -> ID .

  ! shift/reduce conflict for LSQUARE resolved as shift
    EQUALS          shift and go to state 52
    LSQUARE         shift and go to state 53
    ID              reduce using rule 22 (type -> ID .)

  ! LSQUARE         [ reduce using rule 22 (type -> ID .) ]


state 29

    (46) statement -> LBRACE . body RBRACE
    (15) body -> . var_decl body
    (16) body -> . method_decl body
    (17) body -> . statement body
    (18) body -> . empty
    (9) var_decl -> . type ID SEMICOLON
    (10) var_decl -> . type ID EQUAL expr SEMICOLON
    (11) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (46) statement -> . LBRACE body RBRACE
    (47) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (48) statement -> . IF LPAREN expr RPAREN statement
    (49) statement -> . WHILE LPAREN expr RPAREN statement
    (50) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (51) statement -> . ID EQUALS expr SEMICOLON
    (52) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (53) empty -> .
    (19) type -> . INT
    (20) type -> . BOOLEAN
    (21) type -> . STRING
    (22) type -> . ID
    (23) type -> . type LSQUARE RSQUARE

    LBRACE          shift and go to state 29
    IF              shift and go to state 36
    WHILE           shift and go to state 37
    SYSTEM          shift and go to state 38
    ID              shift and go to state 28
    RBRACE          reduce using rule 53 (empty -> .)
    INT             shift and go to state 11
    BOOLEAN         shift and go to state 12
    STRING          shift and go to state 13

    body                           shift and go to state 54
    var_decl                       shift and go to state 31
    method_decl                    shift and go to state 32
    statement                      shift and go to state 33
    empty                          shift and go to state 34
    type                           shift and go to state 35

state 30

    (7) class_decl -> CLASS ID LBRACE body . RBRACE

    RBRACE          shift and go to state 55


state 31

    (15) body -> var_decl . body
    (15) body -> . var_decl body
    (16) body -> . method_decl body
    (17) body -> . statement body
    (18) body -> . empty
    (9) var_decl -> . type ID SEMICOLON
    (10) var_decl -> . type ID EQUAL expr SEMICOLON
    (11) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (46) statement -> . LBRACE body RBRACE
    (47) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (48) statement -> . IF LPAREN expr RPAREN statement
    (49) statement -> . WHILE LPAREN expr RPAREN statement
    (50) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (51) statement -> . ID EQUALS expr SEMICOLON
    (52) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (53) empty -> .
    (19) type -> . INT
    (20) type -> . BOOLEAN
    (21) type -> . STRING
    (22) type -> . ID
    (23) type -> . type LSQUARE RSQUARE

    LBRACE          shift and go to state 29
    IF              shift and go to state 36
    WHILE           shift and go to state 37
    SYSTEM          shift and go to state 38
    ID              shift and go to state 28
    RBRACE          reduce using rule 53 (empty -> .)
    INT             shift and go to state 11
    BOOLEAN         shift and go to state 12
    STRING          shift and go to state 13

    var_decl                       shift and go to state 31
    body                           shift and go to state 56
    method_decl                    shift and go to state 32
    statement                      shift and go to state 33
    empty                          shift and go to state 34
    type                           shift and go to state 35

state 32

    (16) body -> method_decl . body
    (15) body -> . var_decl body
    (16) body -> . method_decl body
    (17) body -> . statement body
    (18) body -> . empty
    (9) var_decl -> . type ID SEMICOLON
    (10) var_decl -> . type ID EQUAL expr SEMICOLON
    (11) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (46) statement -> . LBRACE body RBRACE
    (47) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (48) statement -> . IF LPAREN expr RPAREN statement
    (49) statement -> . WHILE LPAREN expr RPAREN statement
    (50) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (51) statement -> . ID EQUALS expr SEMICOLON
    (52) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (53) empty -> .
    (19) type -> . INT
    (20) type -> . BOOLEAN
    (21) type -> . STRING
    (22) type -> . ID
    (23) type -> . type LSQUARE RSQUARE

    LBRACE          shift and go to state 29
    IF              shift and go to state 36
    WHILE           shift and go to state 37
    SYSTEM          shift and go to state 38
    ID              shift and go to state 28
    RBRACE          reduce using rule 53 (empty -> .)
    INT             shift and go to state 11
    BOOLEAN         shift and go to state 12
    STRING          shift and go to state 13

    method_decl                    shift and go to state 32
    body                           shift and go to state 57
    var_decl                       shift and go to state 31
    statement                      shift and go to state 33
    empty                          shift and go to state 34
    type                           shift and go to state 35

state 33

    (17) body -> statement . body
    (15) body -> . var_decl body
    (16) body -> . method_decl body
    (17) body -> . statement body
    (18) body -> . empty
    (9) var_decl -> . type ID SEMICOLON
    (10) var_decl -> . type ID EQUAL expr SEMICOLON
    (11) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (46) statement -> . LBRACE body RBRACE
    (47) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (48) statement -> . IF LPAREN expr RPAREN statement
    (49) statement -> . WHILE LPAREN expr RPAREN statement
    (50) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (51) statement -> . ID EQUALS expr SEMICOLON
    (52) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (53) empty -> .
    (19) type -> . INT
    (20) type -> . BOOLEAN
    (21) type -> . STRING
    (22) type -> . ID
    (23) type -> . type LSQUARE RSQUARE

    LBRACE          shift and go to state 29
    IF              shift and go to state 36
    WHILE           shift and go to state 37
    SYSTEM          shift and go to state 38
    ID              shift and go to state 28
    RBRACE          reduce using rule 53 (empty -> .)
    INT             shift and go to state 11
    BOOLEAN         shift and go to state 12
    STRING          shift and go to state 13

    statement                      shift and go to state 33
    body                           shift and go to state 58
    var_decl                       shift and go to state 31
    method_decl                    shift and go to state 32
    empty                          shift and go to state 34
    type                           shift and go to state 35

state 34

    (18) body -> empty .

    RBRACE          reduce using rule 18 (body -> empty .)


state 35

    (9) var_decl -> type . ID SEMICOLON
    (10) var_decl -> type . ID EQUAL expr SEMICOLON
    (11) method_decl -> type . ID LPAREN params RPAREN LBRACE body RBRACE
    (23) type -> type . LSQUARE RSQUARE

    ID              shift and go to state 59
    LSQUARE         shift and go to state 20


state 36

    (47) statement -> IF . LPAREN expr RPAREN statement ELSE statement
    (48) statement -> IF . LPAREN expr RPAREN statement

    LPAREN          shift and go to state 60


state 37

    (49) statement -> WHILE . LPAREN expr RPAREN statement

    LPAREN          shift and go to state 61


state 38

    (50) statement -> SYSTEM . DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON

    DOT             shift and go to state 62


state 39

    (8) import_decl -> IMPORT ID DOT ID . SEMICOLON

    SEMICOLON       shift and go to state 63


state 40

    (35) factor -> ID .
    (36) factor -> ID . LSQUARE expr RSQUARE
    (37) factor -> ID . DOT ID
    (38) factor -> ID . DOT ID LPAREN args RPAREN
    (39) factor -> ID . LPAREN args RPAREN

    TIMES           reduce using rule 35 (factor -> ID .)
    DIVIDE          reduce using rule 35 (factor -> ID .)
    SEMICOLON       reduce using rule 35 (factor -> ID .)
    PLUS            reduce using rule 35 (factor -> ID .)
    MINUS           reduce using rule 35 (factor -> ID .)
    RPAREN          reduce using rule 35 (factor -> ID .)
    RSQUARE         reduce using rule 35 (factor -> ID .)
    COMMA           reduce using rule 35 (factor -> ID .)
    LSQUARE         shift and go to state 64
    DOT             shift and go to state 65
    LPAREN          shift and go to state 66


state 41

    (10) var_decl -> type ID EQUAL expr . SEMICOLON
    (24) expr -> expr . PLUS term
    (25) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 67
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 42

    (26) expr -> term .
    (27) term -> term . TIMES factor
    (28) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 26 (expr -> term .)
    PLUS            reduce using rule 26 (expr -> term .)
    MINUS           reduce using rule 26 (expr -> term .)
    RPAREN          reduce using rule 26 (expr -> term .)
    RSQUARE         reduce using rule 26 (expr -> term .)
    COMMA           reduce using rule 26 (expr -> term .)
    TIMES           shift and go to state 70
    DIVIDE          shift and go to state 71


state 43

    (30) factor -> MINUS . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    factor                         shift and go to state 72

state 44

    (29) term -> factor .

    TIMES           reduce using rule 29 (term -> factor .)
    DIVIDE          reduce using rule 29 (term -> factor .)
    SEMICOLON       reduce using rule 29 (term -> factor .)
    PLUS            reduce using rule 29 (term -> factor .)
    MINUS           reduce using rule 29 (term -> factor .)
    RPAREN          reduce using rule 29 (term -> factor .)
    RSQUARE         reduce using rule 29 (term -> factor .)
    COMMA           reduce using rule 29 (term -> factor .)


state 45

    (31) factor -> NOT . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    factor                         shift and go to state 73

state 46

    (32) factor -> INT_LITERAL .

    TIMES           reduce using rule 32 (factor -> INT_LITERAL .)
    DIVIDE          reduce using rule 32 (factor -> INT_LITERAL .)
    SEMICOLON       reduce using rule 32 (factor -> INT_LITERAL .)
    PLUS            reduce using rule 32 (factor -> INT_LITERAL .)
    MINUS           reduce using rule 32 (factor -> INT_LITERAL .)
    RPAREN          reduce using rule 32 (factor -> INT_LITERAL .)
    RSQUARE         reduce using rule 32 (factor -> INT_LITERAL .)
    COMMA           reduce using rule 32 (factor -> INT_LITERAL .)


state 47

    (33) factor -> BOOLEAN_LITERAL .

    TIMES           reduce using rule 33 (factor -> BOOLEAN_LITERAL .)
    DIVIDE          reduce using rule 33 (factor -> BOOLEAN_LITERAL .)
    SEMICOLON       reduce using rule 33 (factor -> BOOLEAN_LITERAL .)
    PLUS            reduce using rule 33 (factor -> BOOLEAN_LITERAL .)
    MINUS           reduce using rule 33 (factor -> BOOLEAN_LITERAL .)
    RPAREN          reduce using rule 33 (factor -> BOOLEAN_LITERAL .)
    RSQUARE         reduce using rule 33 (factor -> BOOLEAN_LITERAL .)
    COMMA           reduce using rule 33 (factor -> BOOLEAN_LITERAL .)


state 48

    (34) factor -> STRING_LITERAL .

    TIMES           reduce using rule 34 (factor -> STRING_LITERAL .)
    DIVIDE          reduce using rule 34 (factor -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 34 (factor -> STRING_LITERAL .)
    PLUS            reduce using rule 34 (factor -> STRING_LITERAL .)
    MINUS           reduce using rule 34 (factor -> STRING_LITERAL .)
    RPAREN          reduce using rule 34 (factor -> STRING_LITERAL .)
    RSQUARE         reduce using rule 34 (factor -> STRING_LITERAL .)
    COMMA           reduce using rule 34 (factor -> STRING_LITERAL .)


state 49

    (42) factor -> LPAREN . expr RPAREN
    (24) expr -> . expr PLUS term
    (25) expr -> . expr MINUS term
    (26) expr -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    expr                           shift and go to state 74
    term                           shift and go to state 42
    factor                         shift and go to state 44

state 50

    (40) factor -> NEW . ID LPAREN RPAREN
    (41) factor -> NEW . INT LSQUARE expr RSQUARE

    ID              shift and go to state 75
    INT             shift and go to state 76


state 51

    (6) class_decl -> CLASS ID EXTENDS ID LBRACE . body RBRACE
    (15) body -> . var_decl body
    (16) body -> . method_decl body
    (17) body -> . statement body
    (18) body -> . empty
    (9) var_decl -> . type ID SEMICOLON
    (10) var_decl -> . type ID EQUAL expr SEMICOLON
    (11) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (46) statement -> . LBRACE body RBRACE
    (47) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (48) statement -> . IF LPAREN expr RPAREN statement
    (49) statement -> . WHILE LPAREN expr RPAREN statement
    (50) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (51) statement -> . ID EQUALS expr SEMICOLON
    (52) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (53) empty -> .
    (19) type -> . INT
    (20) type -> . BOOLEAN
    (21) type -> . STRING
    (22) type -> . ID
    (23) type -> . type LSQUARE RSQUARE

    LBRACE          shift and go to state 29
    IF              shift and go to state 36
    WHILE           shift and go to state 37
    SYSTEM          shift and go to state 38
    ID              shift and go to state 28
    RBRACE          reduce using rule 53 (empty -> .)
    INT             shift and go to state 11
    BOOLEAN         shift and go to state 12
    STRING          shift and go to state 13

    body                           shift and go to state 77
    var_decl                       shift and go to state 31
    method_decl                    shift and go to state 32
    statement                      shift and go to state 33
    empty                          shift and go to state 34
    type                           shift and go to state 35

state 52

    (51) statement -> ID EQUALS . expr SEMICOLON
    (24) expr -> . expr PLUS term
    (25) expr -> . expr MINUS term
    (26) expr -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    expr                           shift and go to state 78
    term                           shift and go to state 42
    factor                         shift and go to state 44

state 53

    (52) statement -> ID LSQUARE . expr RSQUARE EQUALS expr SEMICOLON
    (24) expr -> . expr PLUS term
    (25) expr -> . expr MINUS term
    (26) expr -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    expr                           shift and go to state 79
    term                           shift and go to state 42
    factor                         shift and go to state 44

state 54

    (46) statement -> LBRACE body . RBRACE

    RBRACE          shift and go to state 80


state 55

    (7) class_decl -> CLASS ID LBRACE body RBRACE .

    CLASS           reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    IMPORT          reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    INT             reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    STRING          reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    ID              reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    $end            reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)


state 56

    (15) body -> var_decl body .

    RBRACE          reduce using rule 15 (body -> var_decl body .)


state 57

    (16) body -> method_decl body .

    RBRACE          reduce using rule 16 (body -> method_decl body .)


state 58

    (17) body -> statement body .

    RBRACE          reduce using rule 17 (body -> statement body .)


state 59

    (9) var_decl -> type ID . SEMICOLON
    (10) var_decl -> type ID . EQUAL expr SEMICOLON
    (11) method_decl -> type ID . LPAREN params RPAREN LBRACE body RBRACE

    SEMICOLON       shift and go to state 24
    EQUAL           shift and go to state 25
    LPAREN          shift and go to state 81


state 60

    (47) statement -> IF LPAREN . expr RPAREN statement ELSE statement
    (48) statement -> IF LPAREN . expr RPAREN statement
    (24) expr -> . expr PLUS term
    (25) expr -> . expr MINUS term
    (26) expr -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    expr                           shift and go to state 82
    term                           shift and go to state 42
    factor                         shift and go to state 44

state 61

    (49) statement -> WHILE LPAREN . expr RPAREN statement
    (24) expr -> . expr PLUS term
    (25) expr -> . expr MINUS term
    (26) expr -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    expr                           shift and go to state 83
    term                           shift and go to state 42
    factor                         shift and go to state 44

state 62

    (50) statement -> SYSTEM DOT . OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON

    OUT             shift and go to state 84


state 63

    (8) import_decl -> IMPORT ID DOT ID SEMICOLON .

    CLASS           reduce using rule 8 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    IMPORT          reduce using rule 8 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    INT             reduce using rule 8 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    BOOLEAN         reduce using rule 8 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    STRING          reduce using rule 8 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    ID              reduce using rule 8 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    $end            reduce using rule 8 (import_decl -> IMPORT ID DOT ID SEMICOLON .)


state 64

    (36) factor -> ID LSQUARE . expr RSQUARE
    (24) expr -> . expr PLUS term
    (25) expr -> . expr MINUS term
    (26) expr -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    expr                           shift and go to state 85
    term                           shift and go to state 42
    factor                         shift and go to state 44

state 65

    (37) factor -> ID DOT . ID
    (38) factor -> ID DOT . ID LPAREN args RPAREN

    ID              shift and go to state 86


state 66

    (39) factor -> ID LPAREN . args RPAREN
    (43) args -> . expr
    (44) args -> . expr COMMA args
    (45) args -> . empty
    (24) expr -> . expr PLUS term
    (25) expr -> . expr MINUS term
    (26) expr -> . term
    (53) empty -> .
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    RPAREN          reduce using rule 53 (empty -> .)
    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    args                           shift and go to state 87
    expr                           shift and go to state 88
    empty                          shift and go to state 89
    term                           shift and go to state 42
    factor                         shift and go to state 44

state 67

    (10) var_decl -> type ID EQUAL expr SEMICOLON .

    CLASS           reduce using rule 10 (var_decl -> type ID EQUAL expr SEMICOLON .)
    IMPORT          reduce using rule 10 (var_decl -> type ID EQUAL expr SEMICOLON .)
    INT             reduce using rule 10 (var_decl -> type ID EQUAL expr SEMICOLON .)
    BOOLEAN         reduce using rule 10 (var_decl -> type ID EQUAL expr SEMICOLON .)
    STRING          reduce using rule 10 (var_decl -> type ID EQUAL expr SEMICOLON .)
    ID              reduce using rule 10 (var_decl -> type ID EQUAL expr SEMICOLON .)
    $end            reduce using rule 10 (var_decl -> type ID EQUAL expr SEMICOLON .)
    LBRACE          reduce using rule 10 (var_decl -> type ID EQUAL expr SEMICOLON .)
    IF              reduce using rule 10 (var_decl -> type ID EQUAL expr SEMICOLON .)
    WHILE           reduce using rule 10 (var_decl -> type ID EQUAL expr SEMICOLON .)
    SYSTEM          reduce using rule 10 (var_decl -> type ID EQUAL expr SEMICOLON .)
    RBRACE          reduce using rule 10 (var_decl -> type ID EQUAL expr SEMICOLON .)


state 68

    (24) expr -> expr PLUS . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    term                           shift and go to state 90
    factor                         shift and go to state 44

state 69

    (25) expr -> expr MINUS . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    term                           shift and go to state 91
    factor                         shift and go to state 44

state 70

    (27) term -> term TIMES . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    factor                         shift and go to state 92

state 71

    (28) term -> term DIVIDE . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    factor                         shift and go to state 93

state 72

    (30) factor -> MINUS factor .

    TIMES           reduce using rule 30 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 30 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 30 (factor -> MINUS factor .)
    PLUS            reduce using rule 30 (factor -> MINUS factor .)
    MINUS           reduce using rule 30 (factor -> MINUS factor .)
    RPAREN          reduce using rule 30 (factor -> MINUS factor .)
    RSQUARE         reduce using rule 30 (factor -> MINUS factor .)
    COMMA           reduce using rule 30 (factor -> MINUS factor .)


state 73

    (31) factor -> NOT factor .

    TIMES           reduce using rule 31 (factor -> NOT factor .)
    DIVIDE          reduce using rule 31 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 31 (factor -> NOT factor .)
    PLUS            reduce using rule 31 (factor -> NOT factor .)
    MINUS           reduce using rule 31 (factor -> NOT factor .)
    RPAREN          reduce using rule 31 (factor -> NOT factor .)
    RSQUARE         reduce using rule 31 (factor -> NOT factor .)
    COMMA           reduce using rule 31 (factor -> NOT factor .)


state 74

    (42) factor -> LPAREN expr . RPAREN
    (24) expr -> expr . PLUS term
    (25) expr -> expr . MINUS term

    RPAREN          shift and go to state 94
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 75

    (40) factor -> NEW ID . LPAREN RPAREN

    LPAREN          shift and go to state 95


state 76

    (41) factor -> NEW INT . LSQUARE expr RSQUARE

    LSQUARE         shift and go to state 96


state 77

    (6) class_decl -> CLASS ID EXTENDS ID LBRACE body . RBRACE

    RBRACE          shift and go to state 97


state 78

    (51) statement -> ID EQUALS expr . SEMICOLON
    (24) expr -> expr . PLUS term
    (25) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 98
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 79

    (52) statement -> ID LSQUARE expr . RSQUARE EQUALS expr SEMICOLON
    (24) expr -> expr . PLUS term
    (25) expr -> expr . MINUS term

    RSQUARE         shift and go to state 99
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 80

    (46) statement -> LBRACE body RBRACE .

    LBRACE          reduce using rule 46 (statement -> LBRACE body RBRACE .)
    IF              reduce using rule 46 (statement -> LBRACE body RBRACE .)
    WHILE           reduce using rule 46 (statement -> LBRACE body RBRACE .)
    SYSTEM          reduce using rule 46 (statement -> LBRACE body RBRACE .)
    ID              reduce using rule 46 (statement -> LBRACE body RBRACE .)
    INT             reduce using rule 46 (statement -> LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 46 (statement -> LBRACE body RBRACE .)
    STRING          reduce using rule 46 (statement -> LBRACE body RBRACE .)
    RBRACE          reduce using rule 46 (statement -> LBRACE body RBRACE .)
    ELSE            reduce using rule 46 (statement -> LBRACE body RBRACE .)


state 81

    (11) method_decl -> type ID LPAREN . params RPAREN LBRACE body RBRACE
    (12) params -> . type ID
    (13) params -> . type ID COMMA params
    (14) params -> . empty
    (19) type -> . INT
    (20) type -> . BOOLEAN
    (21) type -> . STRING
    (22) type -> . ID
    (23) type -> . type LSQUARE RSQUARE
    (53) empty -> .

    INT             shift and go to state 11
    BOOLEAN         shift and go to state 12
    STRING          shift and go to state 13
    ID              shift and go to state 8
    RPAREN          reduce using rule 53 (empty -> .)

    type                           shift and go to state 100
    params                         shift and go to state 101
    empty                          shift and go to state 102

state 82

    (47) statement -> IF LPAREN expr . RPAREN statement ELSE statement
    (48) statement -> IF LPAREN expr . RPAREN statement
    (24) expr -> expr . PLUS term
    (25) expr -> expr . MINUS term

    RPAREN          shift and go to state 103
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 83

    (49) statement -> WHILE LPAREN expr . RPAREN statement
    (24) expr -> expr . PLUS term
    (25) expr -> expr . MINUS term

    RPAREN          shift and go to state 104
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 84

    (50) statement -> SYSTEM DOT OUT . DOT PRINTLN LPAREN expr RPAREN SEMICOLON

    DOT             shift and go to state 105


state 85

    (36) factor -> ID LSQUARE expr . RSQUARE
    (24) expr -> expr . PLUS term
    (25) expr -> expr . MINUS term

    RSQUARE         shift and go to state 106
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 86

    (37) factor -> ID DOT ID .
    (38) factor -> ID DOT ID . LPAREN args RPAREN

    TIMES           reduce using rule 37 (factor -> ID DOT ID .)
    DIVIDE          reduce using rule 37 (factor -> ID DOT ID .)
    SEMICOLON       reduce using rule 37 (factor -> ID DOT ID .)
    PLUS            reduce using rule 37 (factor -> ID DOT ID .)
    MINUS           reduce using rule 37 (factor -> ID DOT ID .)
    RPAREN          reduce using rule 37 (factor -> ID DOT ID .)
    RSQUARE         reduce using rule 37 (factor -> ID DOT ID .)
    COMMA           reduce using rule 37 (factor -> ID DOT ID .)
    LPAREN          shift and go to state 107


state 87

    (39) factor -> ID LPAREN args . RPAREN

    RPAREN          shift and go to state 108


state 88

    (43) args -> expr .
    (44) args -> expr . COMMA args
    (24) expr -> expr . PLUS term
    (25) expr -> expr . MINUS term

    RPAREN          reduce using rule 43 (args -> expr .)
    COMMA           shift and go to state 109
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 89

    (45) args -> empty .

    RPAREN          reduce using rule 45 (args -> empty .)


state 90

    (24) expr -> expr PLUS term .
    (27) term -> term . TIMES factor
    (28) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 24 (expr -> expr PLUS term .)
    PLUS            reduce using rule 24 (expr -> expr PLUS term .)
    MINUS           reduce using rule 24 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 24 (expr -> expr PLUS term .)
    RSQUARE         reduce using rule 24 (expr -> expr PLUS term .)
    COMMA           reduce using rule 24 (expr -> expr PLUS term .)
    TIMES           shift and go to state 70
    DIVIDE          shift and go to state 71


state 91

    (25) expr -> expr MINUS term .
    (27) term -> term . TIMES factor
    (28) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 25 (expr -> expr MINUS term .)
    PLUS            reduce using rule 25 (expr -> expr MINUS term .)
    MINUS           reduce using rule 25 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 25 (expr -> expr MINUS term .)
    RSQUARE         reduce using rule 25 (expr -> expr MINUS term .)
    COMMA           reduce using rule 25 (expr -> expr MINUS term .)
    TIMES           shift and go to state 70
    DIVIDE          shift and go to state 71


state 92

    (27) term -> term TIMES factor .

    TIMES           reduce using rule 27 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 27 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 27 (term -> term TIMES factor .)
    PLUS            reduce using rule 27 (term -> term TIMES factor .)
    MINUS           reduce using rule 27 (term -> term TIMES factor .)
    RPAREN          reduce using rule 27 (term -> term TIMES factor .)
    RSQUARE         reduce using rule 27 (term -> term TIMES factor .)
    COMMA           reduce using rule 27 (term -> term TIMES factor .)


state 93

    (28) term -> term DIVIDE factor .

    TIMES           reduce using rule 28 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 28 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 28 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 28 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 28 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 28 (term -> term DIVIDE factor .)
    RSQUARE         reduce using rule 28 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 28 (term -> term DIVIDE factor .)


state 94

    (42) factor -> LPAREN expr RPAREN .

    TIMES           reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    RSQUARE         reduce using rule 42 (factor -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 42 (factor -> LPAREN expr RPAREN .)


state 95

    (40) factor -> NEW ID LPAREN . RPAREN

    RPAREN          shift and go to state 110


state 96

    (41) factor -> NEW INT LSQUARE . expr RSQUARE
    (24) expr -> . expr PLUS term
    (25) expr -> . expr MINUS term
    (26) expr -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    expr                           shift and go to state 111
    term                           shift and go to state 42
    factor                         shift and go to state 44

state 97

    (6) class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .

    CLASS           reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    IMPORT          reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    INT             reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    STRING          reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    ID              reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    $end            reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)


state 98

    (51) statement -> ID EQUALS expr SEMICOLON .

    LBRACE          reduce using rule 51 (statement -> ID EQUALS expr SEMICOLON .)
    IF              reduce using rule 51 (statement -> ID EQUALS expr SEMICOLON .)
    WHILE           reduce using rule 51 (statement -> ID EQUALS expr SEMICOLON .)
    SYSTEM          reduce using rule 51 (statement -> ID EQUALS expr SEMICOLON .)
    ID              reduce using rule 51 (statement -> ID EQUALS expr SEMICOLON .)
    INT             reduce using rule 51 (statement -> ID EQUALS expr SEMICOLON .)
    BOOLEAN         reduce using rule 51 (statement -> ID EQUALS expr SEMICOLON .)
    STRING          reduce using rule 51 (statement -> ID EQUALS expr SEMICOLON .)
    RBRACE          reduce using rule 51 (statement -> ID EQUALS expr SEMICOLON .)
    ELSE            reduce using rule 51 (statement -> ID EQUALS expr SEMICOLON .)


state 99

    (52) statement -> ID LSQUARE expr RSQUARE . EQUALS expr SEMICOLON

    EQUALS          shift and go to state 112


state 100

    (12) params -> type . ID
    (13) params -> type . ID COMMA params
    (23) type -> type . LSQUARE RSQUARE

    ID              shift and go to state 113
    LSQUARE         shift and go to state 20


state 101

    (11) method_decl -> type ID LPAREN params . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 114


state 102

    (14) params -> empty .

    RPAREN          reduce using rule 14 (params -> empty .)


state 103

    (47) statement -> IF LPAREN expr RPAREN . statement ELSE statement
    (48) statement -> IF LPAREN expr RPAREN . statement
    (46) statement -> . LBRACE body RBRACE
    (47) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (48) statement -> . IF LPAREN expr RPAREN statement
    (49) statement -> . WHILE LPAREN expr RPAREN statement
    (50) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (51) statement -> . ID EQUALS expr SEMICOLON
    (52) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON

    LBRACE          shift and go to state 29
    IF              shift and go to state 36
    WHILE           shift and go to state 37
    SYSTEM          shift and go to state 38
    ID              shift and go to state 116

    statement                      shift and go to state 115

state 104

    (49) statement -> WHILE LPAREN expr RPAREN . statement
    (46) statement -> . LBRACE body RBRACE
    (47) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (48) statement -> . IF LPAREN expr RPAREN statement
    (49) statement -> . WHILE LPAREN expr RPAREN statement
    (50) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (51) statement -> . ID EQUALS expr SEMICOLON
    (52) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON

    LBRACE          shift and go to state 29
    IF              shift and go to state 36
    WHILE           shift and go to state 37
    SYSTEM          shift and go to state 38
    ID              shift and go to state 116

    statement                      shift and go to state 117

state 105

    (50) statement -> SYSTEM DOT OUT DOT . PRINTLN LPAREN expr RPAREN SEMICOLON

    PRINTLN         shift and go to state 118


state 106

    (36) factor -> ID LSQUARE expr RSQUARE .

    TIMES           reduce using rule 36 (factor -> ID LSQUARE expr RSQUARE .)
    DIVIDE          reduce using rule 36 (factor -> ID LSQUARE expr RSQUARE .)
    SEMICOLON       reduce using rule 36 (factor -> ID LSQUARE expr RSQUARE .)
    PLUS            reduce using rule 36 (factor -> ID LSQUARE expr RSQUARE .)
    MINUS           reduce using rule 36 (factor -> ID LSQUARE expr RSQUARE .)
    RPAREN          reduce using rule 36 (factor -> ID LSQUARE expr RSQUARE .)
    RSQUARE         reduce using rule 36 (factor -> ID LSQUARE expr RSQUARE .)
    COMMA           reduce using rule 36 (factor -> ID LSQUARE expr RSQUARE .)


state 107

    (38) factor -> ID DOT ID LPAREN . args RPAREN
    (43) args -> . expr
    (44) args -> . expr COMMA args
    (45) args -> . empty
    (24) expr -> . expr PLUS term
    (25) expr -> . expr MINUS term
    (26) expr -> . term
    (53) empty -> .
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    RPAREN          reduce using rule 53 (empty -> .)
    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    args                           shift and go to state 119
    expr                           shift and go to state 88
    empty                          shift and go to state 89
    term                           shift and go to state 42
    factor                         shift and go to state 44

state 108

    (39) factor -> ID LPAREN args RPAREN .

    TIMES           reduce using rule 39 (factor -> ID LPAREN args RPAREN .)
    DIVIDE          reduce using rule 39 (factor -> ID LPAREN args RPAREN .)
    SEMICOLON       reduce using rule 39 (factor -> ID LPAREN args RPAREN .)
    PLUS            reduce using rule 39 (factor -> ID LPAREN args RPAREN .)
    MINUS           reduce using rule 39 (factor -> ID LPAREN args RPAREN .)
    RPAREN          reduce using rule 39 (factor -> ID LPAREN args RPAREN .)
    RSQUARE         reduce using rule 39 (factor -> ID LPAREN args RPAREN .)
    COMMA           reduce using rule 39 (factor -> ID LPAREN args RPAREN .)


state 109

    (44) args -> expr COMMA . args
    (43) args -> . expr
    (44) args -> . expr COMMA args
    (45) args -> . empty
    (24) expr -> . expr PLUS term
    (25) expr -> . expr MINUS term
    (26) expr -> . term
    (53) empty -> .
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    RPAREN          reduce using rule 53 (empty -> .)
    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    expr                           shift and go to state 88
    args                           shift and go to state 120
    empty                          shift and go to state 89
    term                           shift and go to state 42
    factor                         shift and go to state 44

state 110

    (40) factor -> NEW ID LPAREN RPAREN .

    TIMES           reduce using rule 40 (factor -> NEW ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 40 (factor -> NEW ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 40 (factor -> NEW ID LPAREN RPAREN .)
    PLUS            reduce using rule 40 (factor -> NEW ID LPAREN RPAREN .)
    MINUS           reduce using rule 40 (factor -> NEW ID LPAREN RPAREN .)
    RPAREN          reduce using rule 40 (factor -> NEW ID LPAREN RPAREN .)
    RSQUARE         reduce using rule 40 (factor -> NEW ID LPAREN RPAREN .)
    COMMA           reduce using rule 40 (factor -> NEW ID LPAREN RPAREN .)


state 111

    (41) factor -> NEW INT LSQUARE expr . RSQUARE
    (24) expr -> expr . PLUS term
    (25) expr -> expr . MINUS term

    RSQUARE         shift and go to state 121
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 112

    (52) statement -> ID LSQUARE expr RSQUARE EQUALS . expr SEMICOLON
    (24) expr -> . expr PLUS term
    (25) expr -> . expr MINUS term
    (26) expr -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    expr                           shift and go to state 122
    term                           shift and go to state 42
    factor                         shift and go to state 44

state 113

    (12) params -> type ID .
    (13) params -> type ID . COMMA params

    RPAREN          reduce using rule 12 (params -> type ID .)
    COMMA           shift and go to state 123


state 114

    (11) method_decl -> type ID LPAREN params RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 124


state 115

    (47) statement -> IF LPAREN expr RPAREN statement . ELSE statement
    (48) statement -> IF LPAREN expr RPAREN statement .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 125
    LBRACE          reduce using rule 48 (statement -> IF LPAREN expr RPAREN statement .)
    IF              reduce using rule 48 (statement -> IF LPAREN expr RPAREN statement .)
    WHILE           reduce using rule 48 (statement -> IF LPAREN expr RPAREN statement .)
    SYSTEM          reduce using rule 48 (statement -> IF LPAREN expr RPAREN statement .)
    ID              reduce using rule 48 (statement -> IF LPAREN expr RPAREN statement .)
    INT             reduce using rule 48 (statement -> IF LPAREN expr RPAREN statement .)
    BOOLEAN         reduce using rule 48 (statement -> IF LPAREN expr RPAREN statement .)
    STRING          reduce using rule 48 (statement -> IF LPAREN expr RPAREN statement .)
    RBRACE          reduce using rule 48 (statement -> IF LPAREN expr RPAREN statement .)

  ! ELSE            [ reduce using rule 48 (statement -> IF LPAREN expr RPAREN statement .) ]


state 116

    (51) statement -> ID . EQUALS expr SEMICOLON
    (52) statement -> ID . LSQUARE expr RSQUARE EQUALS expr SEMICOLON

    EQUALS          shift and go to state 52
    LSQUARE         shift and go to state 53


state 117

    (49) statement -> WHILE LPAREN expr RPAREN statement .

    LBRACE          reduce using rule 49 (statement -> WHILE LPAREN expr RPAREN statement .)
    IF              reduce using rule 49 (statement -> WHILE LPAREN expr RPAREN statement .)
    WHILE           reduce using rule 49 (statement -> WHILE LPAREN expr RPAREN statement .)
    SYSTEM          reduce using rule 49 (statement -> WHILE LPAREN expr RPAREN statement .)
    ID              reduce using rule 49 (statement -> WHILE LPAREN expr RPAREN statement .)
    INT             reduce using rule 49 (statement -> WHILE LPAREN expr RPAREN statement .)
    BOOLEAN         reduce using rule 49 (statement -> WHILE LPAREN expr RPAREN statement .)
    STRING          reduce using rule 49 (statement -> WHILE LPAREN expr RPAREN statement .)
    RBRACE          reduce using rule 49 (statement -> WHILE LPAREN expr RPAREN statement .)
    ELSE            reduce using rule 49 (statement -> WHILE LPAREN expr RPAREN statement .)


state 118

    (50) statement -> SYSTEM DOT OUT DOT PRINTLN . LPAREN expr RPAREN SEMICOLON

    LPAREN          shift and go to state 126


state 119

    (38) factor -> ID DOT ID LPAREN args . RPAREN

    RPAREN          shift and go to state 127


state 120

    (44) args -> expr COMMA args .

    RPAREN          reduce using rule 44 (args -> expr COMMA args .)


state 121

    (41) factor -> NEW INT LSQUARE expr RSQUARE .

    TIMES           reduce using rule 41 (factor -> NEW INT LSQUARE expr RSQUARE .)
    DIVIDE          reduce using rule 41 (factor -> NEW INT LSQUARE expr RSQUARE .)
    SEMICOLON       reduce using rule 41 (factor -> NEW INT LSQUARE expr RSQUARE .)
    PLUS            reduce using rule 41 (factor -> NEW INT LSQUARE expr RSQUARE .)
    MINUS           reduce using rule 41 (factor -> NEW INT LSQUARE expr RSQUARE .)
    RPAREN          reduce using rule 41 (factor -> NEW INT LSQUARE expr RSQUARE .)
    RSQUARE         reduce using rule 41 (factor -> NEW INT LSQUARE expr RSQUARE .)
    COMMA           reduce using rule 41 (factor -> NEW INT LSQUARE expr RSQUARE .)


state 122

    (52) statement -> ID LSQUARE expr RSQUARE EQUALS expr . SEMICOLON
    (24) expr -> expr . PLUS term
    (25) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 128
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 123

    (13) params -> type ID COMMA . params
    (12) params -> . type ID
    (13) params -> . type ID COMMA params
    (14) params -> . empty
    (19) type -> . INT
    (20) type -> . BOOLEAN
    (21) type -> . STRING
    (22) type -> . ID
    (23) type -> . type LSQUARE RSQUARE
    (53) empty -> .

    INT             shift and go to state 11
    BOOLEAN         shift and go to state 12
    STRING          shift and go to state 13
    ID              shift and go to state 8
    RPAREN          reduce using rule 53 (empty -> .)

    type                           shift and go to state 100
    params                         shift and go to state 129
    empty                          shift and go to state 102

state 124

    (11) method_decl -> type ID LPAREN params RPAREN LBRACE . body RBRACE
    (15) body -> . var_decl body
    (16) body -> . method_decl body
    (17) body -> . statement body
    (18) body -> . empty
    (9) var_decl -> . type ID SEMICOLON
    (10) var_decl -> . type ID EQUAL expr SEMICOLON
    (11) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (46) statement -> . LBRACE body RBRACE
    (47) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (48) statement -> . IF LPAREN expr RPAREN statement
    (49) statement -> . WHILE LPAREN expr RPAREN statement
    (50) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (51) statement -> . ID EQUALS expr SEMICOLON
    (52) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (53) empty -> .
    (19) type -> . INT
    (20) type -> . BOOLEAN
    (21) type -> . STRING
    (22) type -> . ID
    (23) type -> . type LSQUARE RSQUARE

    LBRACE          shift and go to state 29
    IF              shift and go to state 36
    WHILE           shift and go to state 37
    SYSTEM          shift and go to state 38
    ID              shift and go to state 28
    RBRACE          reduce using rule 53 (empty -> .)
    INT             shift and go to state 11
    BOOLEAN         shift and go to state 12
    STRING          shift and go to state 13

    type                           shift and go to state 35
    body                           shift and go to state 130
    var_decl                       shift and go to state 31
    method_decl                    shift and go to state 32
    statement                      shift and go to state 33
    empty                          shift and go to state 34

state 125

    (47) statement -> IF LPAREN expr RPAREN statement ELSE . statement
    (46) statement -> . LBRACE body RBRACE
    (47) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (48) statement -> . IF LPAREN expr RPAREN statement
    (49) statement -> . WHILE LPAREN expr RPAREN statement
    (50) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (51) statement -> . ID EQUALS expr SEMICOLON
    (52) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON

    LBRACE          shift and go to state 29
    IF              shift and go to state 36
    WHILE           shift and go to state 37
    SYSTEM          shift and go to state 38
    ID              shift and go to state 116

    statement                      shift and go to state 131

state 126

    (50) statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN . expr RPAREN SEMICOLON
    (24) expr -> . expr PLUS term
    (25) expr -> . expr MINUS term
    (26) expr -> . term
    (27) term -> . term TIMES factor
    (28) term -> . term DIVIDE factor
    (29) term -> . factor
    (30) factor -> . MINUS factor
    (31) factor -> . NOT factor
    (32) factor -> . INT_LITERAL
    (33) factor -> . BOOLEAN_LITERAL
    (34) factor -> . STRING_LITERAL
    (35) factor -> . ID
    (36) factor -> . ID LSQUARE expr RSQUARE
    (37) factor -> . ID DOT ID
    (38) factor -> . ID DOT ID LPAREN args RPAREN
    (39) factor -> . ID LPAREN args RPAREN
    (40) factor -> . NEW ID LPAREN RPAREN
    (41) factor -> . NEW INT LSQUARE expr RSQUARE
    (42) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 43
    NOT             shift and go to state 45
    INT_LITERAL     shift and go to state 46
    BOOLEAN_LITERAL shift and go to state 47
    STRING_LITERAL  shift and go to state 48
    ID              shift and go to state 40
    NEW             shift and go to state 50
    LPAREN          shift and go to state 49

    expr                           shift and go to state 132
    term                           shift and go to state 42
    factor                         shift and go to state 44

state 127

    (38) factor -> ID DOT ID LPAREN args RPAREN .

    TIMES           reduce using rule 38 (factor -> ID DOT ID LPAREN args RPAREN .)
    DIVIDE          reduce using rule 38 (factor -> ID DOT ID LPAREN args RPAREN .)
    SEMICOLON       reduce using rule 38 (factor -> ID DOT ID LPAREN args RPAREN .)
    PLUS            reduce using rule 38 (factor -> ID DOT ID LPAREN args RPAREN .)
    MINUS           reduce using rule 38 (factor -> ID DOT ID LPAREN args RPAREN .)
    RPAREN          reduce using rule 38 (factor -> ID DOT ID LPAREN args RPAREN .)
    RSQUARE         reduce using rule 38 (factor -> ID DOT ID LPAREN args RPAREN .)
    COMMA           reduce using rule 38 (factor -> ID DOT ID LPAREN args RPAREN .)


state 128

    (52) statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .

    LBRACE          reduce using rule 52 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    IF              reduce using rule 52 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    WHILE           reduce using rule 52 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    SYSTEM          reduce using rule 52 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    ID              reduce using rule 52 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    INT             reduce using rule 52 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    BOOLEAN         reduce using rule 52 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    STRING          reduce using rule 52 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    RBRACE          reduce using rule 52 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    ELSE            reduce using rule 52 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)


state 129

    (13) params -> type ID COMMA params .

    RPAREN          reduce using rule 13 (params -> type ID COMMA params .)


state 130

    (11) method_decl -> type ID LPAREN params RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 133


state 131

    (47) statement -> IF LPAREN expr RPAREN statement ELSE statement .

    LBRACE          reduce using rule 47 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    IF              reduce using rule 47 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    WHILE           reduce using rule 47 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    SYSTEM          reduce using rule 47 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    ID              reduce using rule 47 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    INT             reduce using rule 47 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    BOOLEAN         reduce using rule 47 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    STRING          reduce using rule 47 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    RBRACE          reduce using rule 47 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    ELSE            reduce using rule 47 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)


state 132

    (50) statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr . RPAREN SEMICOLON
    (24) expr -> expr . PLUS term
    (25) expr -> expr . MINUS term

    RPAREN          shift and go to state 134
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 133

    (11) method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .

    LBRACE          reduce using rule 11 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 11 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 11 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    SYSTEM          reduce using rule 11 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 11 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 11 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 11 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 11 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 11 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)


state 134

    (50) statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 135


state 135

    (50) statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .

    LBRACE          reduce using rule 50 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    IF              reduce using rule 50 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    WHILE           reduce using rule 50 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    SYSTEM          reduce using rule 50 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    ID              reduce using rule 50 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    INT             reduce using rule 50 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 50 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    STRING          reduce using rule 50 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    RBRACE          reduce using rule 50 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    ELSE            reduce using rule 50 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LSQUARE in state 28 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 115 resolved as shift
