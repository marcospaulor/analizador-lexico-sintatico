Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> body_program
Rule 2     body_program -> class_decl body_program
Rule 3     body_program -> import_decl body_program
Rule 4     body_program -> var_decl body_program
Rule 5     body_program -> empty
Rule 6     class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE
Rule 7     class_decl -> CLASS ID LBRACE body RBRACE
Rule 8     class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE
Rule 9     class_decl -> access_modifier CLASS ID LBRACE body RBRACE
Rule 10    access_modifier -> PUBLIC
Rule 11    access_modifier -> PRIVATE
Rule 12    access_modifier -> PROTECTED
Rule 13    import_decl -> IMPORT ID DOT ID SEMICOLON
Rule 14    import_decl -> IMPORT ID DOT ID DOT ID SEMICOLON
Rule 15    var_decl -> type ID SEMICOLON
Rule 16    var_decl -> type ID EQUAL expr SEMICOLON
Rule 17    method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE
Rule 18    method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
Rule 19    method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE
Rule 20    method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
Rule 21    method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
Rule 22    params -> type ID
Rule 23    params -> type ID COMMA params
Rule 24    params -> empty
Rule 25    body -> var_decl body
Rule 26    body -> method_decl body
Rule 27    body -> statement body
Rule 28    body -> empty
Rule 29    type -> INT
Rule 30    type -> BOOLEAN
Rule 31    type -> STRING
Rule 32    type -> ID
Rule 33    type -> VOID
Rule 34    type -> type LSQUARE RSQUARE
Rule 35    expr -> expr PLUS term
Rule 36    expr -> expr MINUS term
Rule 37    expr -> expr AND term
Rule 38    expr -> expr OR term
Rule 39    expr -> expr EQUALS term
Rule 40    expr -> expr NOT_EQUALS term
Rule 41    expr -> expr LESS_THAN term
Rule 42    expr -> expr LESS_THAN_OR_EQUAL term
Rule 43    expr -> expr GREATER_THAN term
Rule 44    expr -> expr GREATER_THAN_OR_EQUAL term
Rule 45    expr -> term
Rule 46    term -> term TIMES factor
Rule 47    term -> term DIVIDE factor
Rule 48    term -> factor
Rule 49    factor -> MINUS factor
Rule 50    factor -> NOT factor
Rule 51    factor -> INT_LITERAL
Rule 52    factor -> TRUE
Rule 53    factor -> FALSE
Rule 54    factor -> STRING_LITERAL
Rule 55    factor -> ID
Rule 56    factor -> ID LSQUARE expr RSQUARE
Rule 57    factor -> ID DOT ID
Rule 58    factor -> ID DOT ID LPAREN args RPAREN
Rule 59    factor -> ID LPAREN args RPAREN
Rule 60    factor -> NEW ID LPAREN RPAREN
Rule 61    factor -> NEW INT LSQUARE expr RSQUARE
Rule 62    factor -> LPAREN expr RPAREN
Rule 63    args -> expr
Rule 64    args -> expr COMMA args
Rule 65    args -> empty
Rule 66    for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
Rule 67    for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
Rule 68    for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
Rule 69    for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement
Rule 70    assign_expr -> ID EQUALS expr
Rule 71    increment_expr -> ID PLUS_PLUS
Rule 72    increment_expr -> ID MINUS_MINUS
Rule 73    increment_expr -> PLUS_PLUS ID
Rule 74    increment_expr -> MINUS_MINUS ID
Rule 75    statement -> LBRACE body RBRACE
Rule 76    statement -> IF LPAREN expr RPAREN statement ELSE statement
Rule 77    statement -> IF LPAREN expr RPAREN statement
Rule 78    statement -> WHILE LPAREN expr RPAREN statement
Rule 79    statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
Rule 80    statement -> ID EQUALS expr SEMICOLON
Rule 81    statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
Rule 82    statement -> ID DOT ID EQUALS expr SEMICOLON
Rule 83    statement -> ID DOT ID LPAREN args RPAREN SEMICOLON
Rule 84    statement -> ID LPAREN args RPAREN SEMICOLON
Rule 85    statement -> RETURN expr SEMICOLON
Rule 86    statement -> RETURN SEMICOLON
Rule 87    statement -> ID PLUS_PLUS SEMICOLON
Rule 88    statement -> ID MINUS_MINUS SEMICOLON
Rule 89    statement -> PLUS_PLUS ID SEMICOLON
Rule 90    statement -> MINUS_MINUS ID SEMICOLON
Rule 91    statement -> THIS DOT ID EQUAL expr SEMICOLON
Rule 92    statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON
Rule 93    statement -> for_loop
Rule 94    empty -> <empty>

Terminals, with rules where they appear

AND                  : 37
BOOLEAN              : 30
CLASS                : 6 7 8 9
COMMA                : 23 64
DIVIDE               : 47
DOT                  : 13 14 14 57 58 79 79 82 83 91 92
ELSE                 : 76
EQUAL                : 16 91
EQUALS               : 39 70 80 81 82
EXTENDS              : 6 8
FALSE                : 53
FOR                  : 66 67 68 69
GREATER_THAN         : 43
GREATER_THAN_OR_EQUAL : 44
ID                   : 6 6 7 8 8 9 13 13 14 14 14 15 16 17 18 19 20 22 23 32 55 56 57 57 58 58 59 60 70 71 72 73 74 80 81 82 82 83 83 84 87 88 89 90 91 92
IF                   : 76 77
IMPORT               : 13 14
INT                  : 29 61
INT_LITERAL          : 51
LBRACE               : 6 7 8 9 17 18 19 20 21 75
LESS_THAN            : 41
LESS_THAN_OR_EQUAL   : 42
LPAREN               : 17 18 19 20 21 58 59 60 62 66 67 68 69 76 77 78 79 83 84 92
LSQUARE              : 34 56 61 81
MAIN                 : 21
MINUS                : 36 49
MINUS_MINUS          : 72 74 88 90
NEW                  : 60 61
NOT                  : 50
NOT_EQUALS           : 40
OR                   : 38
OUT                  : 79
PLUS                 : 35
PLUS_PLUS            : 71 73 87 89
PRINTLN              : 79
PRIVATE              : 11
PROTECTED            : 12
PUBLIC               : 10 21
RBRACE               : 6 7 8 9 17 18 19 20 21 75
RETURN               : 85 86
RPAREN               : 17 18 19 20 21 58 59 60 62 66 67 68 69 76 77 78 79 83 84 92
RSQUARE              : 34 56 61 81
SEMICOLON            : 13 14 15 16 66 67 67 68 69 69 79 80 81 82 83 84 85 86 87 88 89 90 91 92
STATIC               : 20 21
STRING               : 31
STRING_LITERAL       : 54
SYSTEM               : 79
THIS                 : 91 92
TIMES                : 46
TRUE                 : 52
VOID                 : 21 33
WHILE                : 78
error                : 

Nonterminals, with rules where they appear

access_modifier      : 8 9 18 20
args                 : 58 59 64 83 84 92
assign_expr          : 66 67
body                 : 6 7 8 9 17 18 19 20 21 25 26 27 75
body_program         : 1 2 3 4
class_decl           : 2
empty                : 5 24 28 65
expr                 : 16 35 36 37 38 39 40 41 42 43 44 56 61 62 63 64 66 67 68 69 70 76 77 78 79 80 81 81 82 85 91
factor               : 46 47 48 49 50
for_loop             : 93
import_decl          : 3
increment_expr       : 68 69
method_decl          : 26
params               : 17 18 20 21 23
program              : 0
statement            : 27 66 67 68 69 76 76 77 78
term                 : 35 36 37 38 39 40 41 42 43 44 45 46 47
type                 : 15 16 17 18 19 20 22 23 34
var_decl             : 4 25 66 68

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . body_program
    (2) body_program -> . class_decl body_program
    (3) body_program -> . import_decl body_program
    (4) body_program -> . var_decl body_program
    (5) body_program -> . empty
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> . CLASS ID LBRACE body RBRACE
    (8) class_decl -> . access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE
    (9) class_decl -> . access_modifier CLASS ID LBRACE body RBRACE
    (13) import_decl -> . IMPORT ID DOT ID SEMICOLON
    (14) import_decl -> . IMPORT ID DOT ID DOT ID SEMICOLON
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (94) empty -> .
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE

    CLASS           shift and go to state 7
    IMPORT          shift and go to state 10
    $end            reduce using rule 94 (empty -> .)
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

    program                        shift and go to state 1
    body_program                   shift and go to state 2
    class_decl                     shift and go to state 3
    import_decl                    shift and go to state 4
    var_decl                       shift and go to state 5
    empty                          shift and go to state 6
    access_modifier                shift and go to state 9
    type                           shift and go to state 11

state 1

    (0) S' -> program .



state 2

    (1) program -> body_program .

    $end            reduce using rule 1 (program -> body_program .)


state 3

    (2) body_program -> class_decl . body_program
    (2) body_program -> . class_decl body_program
    (3) body_program -> . import_decl body_program
    (4) body_program -> . var_decl body_program
    (5) body_program -> . empty
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> . CLASS ID LBRACE body RBRACE
    (8) class_decl -> . access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE
    (9) class_decl -> . access_modifier CLASS ID LBRACE body RBRACE
    (13) import_decl -> . IMPORT ID DOT ID SEMICOLON
    (14) import_decl -> . IMPORT ID DOT ID DOT ID SEMICOLON
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (94) empty -> .
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE

    CLASS           shift and go to state 7
    IMPORT          shift and go to state 10
    $end            reduce using rule 94 (empty -> .)
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

    class_decl                     shift and go to state 3
    body_program                   shift and go to state 19
    import_decl                    shift and go to state 4
    var_decl                       shift and go to state 5
    empty                          shift and go to state 6
    access_modifier                shift and go to state 9
    type                           shift and go to state 11

state 4

    (3) body_program -> import_decl . body_program
    (2) body_program -> . class_decl body_program
    (3) body_program -> . import_decl body_program
    (4) body_program -> . var_decl body_program
    (5) body_program -> . empty
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> . CLASS ID LBRACE body RBRACE
    (8) class_decl -> . access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE
    (9) class_decl -> . access_modifier CLASS ID LBRACE body RBRACE
    (13) import_decl -> . IMPORT ID DOT ID SEMICOLON
    (14) import_decl -> . IMPORT ID DOT ID DOT ID SEMICOLON
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (94) empty -> .
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE

    CLASS           shift and go to state 7
    IMPORT          shift and go to state 10
    $end            reduce using rule 94 (empty -> .)
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

    import_decl                    shift and go to state 4
    body_program                   shift and go to state 20
    class_decl                     shift and go to state 3
    var_decl                       shift and go to state 5
    empty                          shift and go to state 6
    access_modifier                shift and go to state 9
    type                           shift and go to state 11

state 5

    (4) body_program -> var_decl . body_program
    (2) body_program -> . class_decl body_program
    (3) body_program -> . import_decl body_program
    (4) body_program -> . var_decl body_program
    (5) body_program -> . empty
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> . CLASS ID LBRACE body RBRACE
    (8) class_decl -> . access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE
    (9) class_decl -> . access_modifier CLASS ID LBRACE body RBRACE
    (13) import_decl -> . IMPORT ID DOT ID SEMICOLON
    (14) import_decl -> . IMPORT ID DOT ID DOT ID SEMICOLON
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (94) empty -> .
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE

    CLASS           shift and go to state 7
    IMPORT          shift and go to state 10
    $end            reduce using rule 94 (empty -> .)
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

    var_decl                       shift and go to state 5
    body_program                   shift and go to state 21
    class_decl                     shift and go to state 3
    import_decl                    shift and go to state 4
    empty                          shift and go to state 6
    access_modifier                shift and go to state 9
    type                           shift and go to state 11

state 6

    (5) body_program -> empty .

    $end            reduce using rule 5 (body_program -> empty .)


state 7

    (6) class_decl -> CLASS . ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> CLASS . ID LBRACE body RBRACE

    ID              shift and go to state 22


state 8

    (32) type -> ID .

    ID              reduce using rule 32 (type -> ID .)
    LSQUARE         reduce using rule 32 (type -> ID .)


state 9

    (8) class_decl -> access_modifier . CLASS ID EXTENDS ID LBRACE body RBRACE
    (9) class_decl -> access_modifier . CLASS ID LBRACE body RBRACE

    CLASS           shift and go to state 23


state 10

    (13) import_decl -> IMPORT . ID DOT ID SEMICOLON
    (14) import_decl -> IMPORT . ID DOT ID DOT ID SEMICOLON

    ID              shift and go to state 24


state 11

    (15) var_decl -> type . ID SEMICOLON
    (16) var_decl -> type . ID EQUAL expr SEMICOLON
    (34) type -> type . LSQUARE RSQUARE

    ID              shift and go to state 25
    LSQUARE         shift and go to state 26


state 12

    (10) access_modifier -> PUBLIC .

    CLASS           reduce using rule 10 (access_modifier -> PUBLIC .)


state 13

    (11) access_modifier -> PRIVATE .

    CLASS           reduce using rule 11 (access_modifier -> PRIVATE .)
    STATIC          reduce using rule 11 (access_modifier -> PRIVATE .)
    INT             reduce using rule 11 (access_modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 11 (access_modifier -> PRIVATE .)
    STRING          reduce using rule 11 (access_modifier -> PRIVATE .)
    ID              reduce using rule 11 (access_modifier -> PRIVATE .)
    VOID            reduce using rule 11 (access_modifier -> PRIVATE .)


state 14

    (12) access_modifier -> PROTECTED .

    CLASS           reduce using rule 12 (access_modifier -> PROTECTED .)
    STATIC          reduce using rule 12 (access_modifier -> PROTECTED .)
    INT             reduce using rule 12 (access_modifier -> PROTECTED .)
    BOOLEAN         reduce using rule 12 (access_modifier -> PROTECTED .)
    STRING          reduce using rule 12 (access_modifier -> PROTECTED .)
    ID              reduce using rule 12 (access_modifier -> PROTECTED .)
    VOID            reduce using rule 12 (access_modifier -> PROTECTED .)


state 15

    (29) type -> INT .

    ID              reduce using rule 29 (type -> INT .)
    LSQUARE         reduce using rule 29 (type -> INT .)


state 16

    (30) type -> BOOLEAN .

    ID              reduce using rule 30 (type -> BOOLEAN .)
    LSQUARE         reduce using rule 30 (type -> BOOLEAN .)


state 17

    (31) type -> STRING .

    ID              reduce using rule 31 (type -> STRING .)
    LSQUARE         reduce using rule 31 (type -> STRING .)


state 18

    (33) type -> VOID .

    ID              reduce using rule 33 (type -> VOID .)
    LSQUARE         reduce using rule 33 (type -> VOID .)


state 19

    (2) body_program -> class_decl body_program .

    $end            reduce using rule 2 (body_program -> class_decl body_program .)


state 20

    (3) body_program -> import_decl body_program .

    $end            reduce using rule 3 (body_program -> import_decl body_program .)


state 21

    (4) body_program -> var_decl body_program .

    $end            reduce using rule 4 (body_program -> var_decl body_program .)


state 22

    (6) class_decl -> CLASS ID . EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> CLASS ID . LBRACE body RBRACE

    EXTENDS         shift and go to state 27
    LBRACE          shift and go to state 28


state 23

    (8) class_decl -> access_modifier CLASS . ID EXTENDS ID LBRACE body RBRACE
    (9) class_decl -> access_modifier CLASS . ID LBRACE body RBRACE

    ID              shift and go to state 29


state 24

    (13) import_decl -> IMPORT ID . DOT ID SEMICOLON
    (14) import_decl -> IMPORT ID . DOT ID DOT ID SEMICOLON

    DOT             shift and go to state 30


state 25

    (15) var_decl -> type ID . SEMICOLON
    (16) var_decl -> type ID . EQUAL expr SEMICOLON

    SEMICOLON       shift and go to state 31
    EQUAL           shift and go to state 32


state 26

    (34) type -> type LSQUARE . RSQUARE

    RSQUARE         shift and go to state 33


state 27

    (6) class_decl -> CLASS ID EXTENDS . ID LBRACE body RBRACE

    ID              shift and go to state 34


state 28

    (7) class_decl -> CLASS ID LBRACE . body RBRACE
    (25) body -> . var_decl body
    (26) body -> . method_decl body
    (27) body -> . statement body
    (28) body -> . empty
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (17) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (20) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (21) method_decl -> . PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (94) empty -> .
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    PUBLIC          shift and go to state 44
    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 35
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    RBRACE          reduce using rule 94 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    FOR             shift and go to state 53

    body                           shift and go to state 37
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42
    access_modifier                shift and go to state 43
    for_loop                       shift and go to state 52

state 29

    (8) class_decl -> access_modifier CLASS ID . EXTENDS ID LBRACE body RBRACE
    (9) class_decl -> access_modifier CLASS ID . LBRACE body RBRACE

    EXTENDS         shift and go to state 54
    LBRACE          shift and go to state 55


state 30

    (13) import_decl -> IMPORT ID DOT . ID SEMICOLON
    (14) import_decl -> IMPORT ID DOT . ID DOT ID SEMICOLON

    ID              shift and go to state 56


state 31

    (15) var_decl -> type ID SEMICOLON .

    CLASS           reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    IMPORT          reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    PUBLIC          reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    PRIVATE         reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    PROTECTED       reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    INT             reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    BOOLEAN         reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    STRING          reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    ID              reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    VOID            reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    $end            reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    LBRACE          reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    IF              reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    WHILE           reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    SYSTEM          reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    RETURN          reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    THIS            reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    FOR             reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    RBRACE          reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    MINUS           reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    NOT             reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    INT_LITERAL     reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    TRUE            reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    FALSE           reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    STRING_LITERAL  reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    NEW             reduce using rule 15 (var_decl -> type ID SEMICOLON .)
    LPAREN          reduce using rule 15 (var_decl -> type ID SEMICOLON .)


state 32

    (16) var_decl -> type ID EQUAL . expr SEMICOLON
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 58
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 33

    (34) type -> type LSQUARE RSQUARE .

    ID              reduce using rule 34 (type -> type LSQUARE RSQUARE .)
    LSQUARE         reduce using rule 34 (type -> type LSQUARE RSQUARE .)


state 34

    (6) class_decl -> CLASS ID EXTENDS ID . LBRACE body RBRACE

    LBRACE          shift and go to state 69


state 35

    (80) statement -> ID . EQUALS expr SEMICOLON
    (81) statement -> ID . LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> ID . DOT ID EQUALS expr SEMICOLON
    (83) statement -> ID . DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> ID . LPAREN args RPAREN SEMICOLON
    (87) statement -> ID . PLUS_PLUS SEMICOLON
    (88) statement -> ID . MINUS_MINUS SEMICOLON
    (32) type -> ID .

  ! shift/reduce conflict for LSQUARE resolved as shift
    EQUALS          shift and go to state 70
    LSQUARE         shift and go to state 71
    DOT             shift and go to state 72
    LPAREN          shift and go to state 73
    PLUS_PLUS       shift and go to state 74
    MINUS_MINUS     shift and go to state 75
    ID              reduce using rule 32 (type -> ID .)

  ! LSQUARE         [ reduce using rule 32 (type -> ID .) ]


state 36

    (75) statement -> LBRACE . body RBRACE
    (25) body -> . var_decl body
    (26) body -> . method_decl body
    (27) body -> . statement body
    (28) body -> . empty
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (17) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (20) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (21) method_decl -> . PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (94) empty -> .
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    PUBLIC          shift and go to state 44
    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 35
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    RBRACE          reduce using rule 94 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    FOR             shift and go to state 53

    body                           shift and go to state 76
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42
    access_modifier                shift and go to state 43
    for_loop                       shift and go to state 52

state 37

    (7) class_decl -> CLASS ID LBRACE body . RBRACE

    RBRACE          shift and go to state 77


state 38

    (25) body -> var_decl . body
    (25) body -> . var_decl body
    (26) body -> . method_decl body
    (27) body -> . statement body
    (28) body -> . empty
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (17) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (20) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (21) method_decl -> . PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (94) empty -> .
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    PUBLIC          shift and go to state 44
    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 35
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    RBRACE          reduce using rule 94 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    FOR             shift and go to state 53

    var_decl                       shift and go to state 38
    body                           shift and go to state 78
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42
    access_modifier                shift and go to state 43
    for_loop                       shift and go to state 52

state 39

    (26) body -> method_decl . body
    (25) body -> . var_decl body
    (26) body -> . method_decl body
    (27) body -> . statement body
    (28) body -> . empty
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (17) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (20) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (21) method_decl -> . PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (94) empty -> .
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    PUBLIC          shift and go to state 44
    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 35
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    RBRACE          reduce using rule 94 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    FOR             shift and go to state 53

    method_decl                    shift and go to state 39
    body                           shift and go to state 79
    var_decl                       shift and go to state 38
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42
    access_modifier                shift and go to state 43
    for_loop                       shift and go to state 52

state 40

    (27) body -> statement . body
    (25) body -> . var_decl body
    (26) body -> . method_decl body
    (27) body -> . statement body
    (28) body -> . empty
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (17) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (20) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (21) method_decl -> . PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (94) empty -> .
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    PUBLIC          shift and go to state 44
    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 35
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    RBRACE          reduce using rule 94 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    FOR             shift and go to state 53

    statement                      shift and go to state 40
    body                           shift and go to state 80
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    empty                          shift and go to state 41
    type                           shift and go to state 42
    access_modifier                shift and go to state 43
    for_loop                       shift and go to state 52

state 41

    (28) body -> empty .

    RBRACE          reduce using rule 28 (body -> empty .)


state 42

    (15) var_decl -> type . ID SEMICOLON
    (16) var_decl -> type . ID EQUAL expr SEMICOLON
    (17) method_decl -> type . ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> type . ID LPAREN RPAREN LBRACE body RBRACE
    (34) type -> type . LSQUARE RSQUARE

    ID              shift and go to state 81
    LSQUARE         shift and go to state 26


state 43

    (18) method_decl -> access_modifier . type ID LPAREN params RPAREN LBRACE body RBRACE
    (20) method_decl -> access_modifier . STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE

    STATIC          shift and go to state 83
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

    type                           shift and go to state 82

state 44

    (21) method_decl -> PUBLIC . STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
    (10) access_modifier -> PUBLIC .

  ! shift/reduce conflict for STATIC resolved as shift
    STATIC          shift and go to state 84
    INT             reduce using rule 10 (access_modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 10 (access_modifier -> PUBLIC .)
    STRING          reduce using rule 10 (access_modifier -> PUBLIC .)
    ID              reduce using rule 10 (access_modifier -> PUBLIC .)
    VOID            reduce using rule 10 (access_modifier -> PUBLIC .)

  ! STATIC          [ reduce using rule 10 (access_modifier -> PUBLIC .) ]


state 45

    (76) statement -> IF . LPAREN expr RPAREN statement ELSE statement
    (77) statement -> IF . LPAREN expr RPAREN statement

    LPAREN          shift and go to state 85


state 46

    (78) statement -> WHILE . LPAREN expr RPAREN statement

    LPAREN          shift and go to state 86


state 47

    (79) statement -> SYSTEM . DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON

    DOT             shift and go to state 87


state 48

    (85) statement -> RETURN . expr SEMICOLON
    (86) statement -> RETURN . SEMICOLON
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    SEMICOLON       shift and go to state 89
    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 88
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 49

    (89) statement -> PLUS_PLUS . ID SEMICOLON

    ID              shift and go to state 90


state 50

    (90) statement -> MINUS_MINUS . ID SEMICOLON

    ID              shift and go to state 91


state 51

    (91) statement -> THIS . DOT ID EQUAL expr SEMICOLON
    (92) statement -> THIS . DOT ID LPAREN args RPAREN SEMICOLON

    DOT             shift and go to state 92


state 52

    (93) statement -> for_loop .

    PUBLIC          reduce using rule 93 (statement -> for_loop .)
    LBRACE          reduce using rule 93 (statement -> for_loop .)
    IF              reduce using rule 93 (statement -> for_loop .)
    WHILE           reduce using rule 93 (statement -> for_loop .)
    SYSTEM          reduce using rule 93 (statement -> for_loop .)
    ID              reduce using rule 93 (statement -> for_loop .)
    RETURN          reduce using rule 93 (statement -> for_loop .)
    PLUS_PLUS       reduce using rule 93 (statement -> for_loop .)
    MINUS_MINUS     reduce using rule 93 (statement -> for_loop .)
    THIS            reduce using rule 93 (statement -> for_loop .)
    INT             reduce using rule 93 (statement -> for_loop .)
    BOOLEAN         reduce using rule 93 (statement -> for_loop .)
    STRING          reduce using rule 93 (statement -> for_loop .)
    VOID            reduce using rule 93 (statement -> for_loop .)
    PRIVATE         reduce using rule 93 (statement -> for_loop .)
    PROTECTED       reduce using rule 93 (statement -> for_loop .)
    FOR             reduce using rule 93 (statement -> for_loop .)
    RBRACE          reduce using rule 93 (statement -> for_loop .)
    ELSE            reduce using rule 93 (statement -> for_loop .)


state 53

    (66) for_loop -> FOR . LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> FOR . LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> FOR . LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> FOR . LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    LPAREN          shift and go to state 93


state 54

    (8) class_decl -> access_modifier CLASS ID EXTENDS . ID LBRACE body RBRACE

    ID              shift and go to state 94


state 55

    (9) class_decl -> access_modifier CLASS ID LBRACE . body RBRACE
    (25) body -> . var_decl body
    (26) body -> . method_decl body
    (27) body -> . statement body
    (28) body -> . empty
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (17) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (20) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (21) method_decl -> . PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (94) empty -> .
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    PUBLIC          shift and go to state 44
    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 35
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    RBRACE          reduce using rule 94 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    FOR             shift and go to state 53

    access_modifier                shift and go to state 43
    body                           shift and go to state 95
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42
    for_loop                       shift and go to state 52

state 56

    (13) import_decl -> IMPORT ID DOT ID . SEMICOLON
    (14) import_decl -> IMPORT ID DOT ID . DOT ID SEMICOLON

    SEMICOLON       shift and go to state 97
    DOT             shift and go to state 96


state 57

    (55) factor -> ID .
    (56) factor -> ID . LSQUARE expr RSQUARE
    (57) factor -> ID . DOT ID
    (58) factor -> ID . DOT ID LPAREN args RPAREN
    (59) factor -> ID . LPAREN args RPAREN

    TIMES           reduce using rule 55 (factor -> ID .)
    DIVIDE          reduce using rule 55 (factor -> ID .)
    SEMICOLON       reduce using rule 55 (factor -> ID .)
    PLUS            reduce using rule 55 (factor -> ID .)
    MINUS           reduce using rule 55 (factor -> ID .)
    AND             reduce using rule 55 (factor -> ID .)
    OR              reduce using rule 55 (factor -> ID .)
    EQUALS          reduce using rule 55 (factor -> ID .)
    NOT_EQUALS      reduce using rule 55 (factor -> ID .)
    LESS_THAN       reduce using rule 55 (factor -> ID .)
    LESS_THAN_OR_EQUAL reduce using rule 55 (factor -> ID .)
    GREATER_THAN    reduce using rule 55 (factor -> ID .)
    GREATER_THAN_OR_EQUAL reduce using rule 55 (factor -> ID .)
    RPAREN          reduce using rule 55 (factor -> ID .)
    RSQUARE         reduce using rule 55 (factor -> ID .)
    COMMA           reduce using rule 55 (factor -> ID .)
    LSQUARE         shift and go to state 98
    DOT             shift and go to state 99
    LPAREN          shift and go to state 100


state 58

    (16) var_decl -> type ID EQUAL expr . SEMICOLON
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    SEMICOLON       shift and go to state 101
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 59

    (45) expr -> term .
    (46) term -> term . TIMES factor
    (47) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 45 (expr -> term .)
    PLUS            reduce using rule 45 (expr -> term .)
    MINUS           reduce using rule 45 (expr -> term .)
    AND             reduce using rule 45 (expr -> term .)
    OR              reduce using rule 45 (expr -> term .)
    EQUALS          reduce using rule 45 (expr -> term .)
    NOT_EQUALS      reduce using rule 45 (expr -> term .)
    LESS_THAN       reduce using rule 45 (expr -> term .)
    LESS_THAN_OR_EQUAL reduce using rule 45 (expr -> term .)
    GREATER_THAN    reduce using rule 45 (expr -> term .)
    GREATER_THAN_OR_EQUAL reduce using rule 45 (expr -> term .)
    RPAREN          reduce using rule 45 (expr -> term .)
    RSQUARE         reduce using rule 45 (expr -> term .)
    COMMA           reduce using rule 45 (expr -> term .)
    TIMES           shift and go to state 112
    DIVIDE          shift and go to state 113


state 60

    (49) factor -> MINUS . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    factor                         shift and go to state 114

state 61

    (48) term -> factor .

    TIMES           reduce using rule 48 (term -> factor .)
    DIVIDE          reduce using rule 48 (term -> factor .)
    SEMICOLON       reduce using rule 48 (term -> factor .)
    PLUS            reduce using rule 48 (term -> factor .)
    MINUS           reduce using rule 48 (term -> factor .)
    AND             reduce using rule 48 (term -> factor .)
    OR              reduce using rule 48 (term -> factor .)
    EQUALS          reduce using rule 48 (term -> factor .)
    NOT_EQUALS      reduce using rule 48 (term -> factor .)
    LESS_THAN       reduce using rule 48 (term -> factor .)
    LESS_THAN_OR_EQUAL reduce using rule 48 (term -> factor .)
    GREATER_THAN    reduce using rule 48 (term -> factor .)
    GREATER_THAN_OR_EQUAL reduce using rule 48 (term -> factor .)
    RPAREN          reduce using rule 48 (term -> factor .)
    RSQUARE         reduce using rule 48 (term -> factor .)
    COMMA           reduce using rule 48 (term -> factor .)


state 62

    (50) factor -> NOT . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    factor                         shift and go to state 115

state 63

    (51) factor -> INT_LITERAL .

    TIMES           reduce using rule 51 (factor -> INT_LITERAL .)
    DIVIDE          reduce using rule 51 (factor -> INT_LITERAL .)
    SEMICOLON       reduce using rule 51 (factor -> INT_LITERAL .)
    PLUS            reduce using rule 51 (factor -> INT_LITERAL .)
    MINUS           reduce using rule 51 (factor -> INT_LITERAL .)
    AND             reduce using rule 51 (factor -> INT_LITERAL .)
    OR              reduce using rule 51 (factor -> INT_LITERAL .)
    EQUALS          reduce using rule 51 (factor -> INT_LITERAL .)
    NOT_EQUALS      reduce using rule 51 (factor -> INT_LITERAL .)
    LESS_THAN       reduce using rule 51 (factor -> INT_LITERAL .)
    LESS_THAN_OR_EQUAL reduce using rule 51 (factor -> INT_LITERAL .)
    GREATER_THAN    reduce using rule 51 (factor -> INT_LITERAL .)
    GREATER_THAN_OR_EQUAL reduce using rule 51 (factor -> INT_LITERAL .)
    RPAREN          reduce using rule 51 (factor -> INT_LITERAL .)
    RSQUARE         reduce using rule 51 (factor -> INT_LITERAL .)
    COMMA           reduce using rule 51 (factor -> INT_LITERAL .)


state 64

    (52) factor -> TRUE .

    TIMES           reduce using rule 52 (factor -> TRUE .)
    DIVIDE          reduce using rule 52 (factor -> TRUE .)
    SEMICOLON       reduce using rule 52 (factor -> TRUE .)
    PLUS            reduce using rule 52 (factor -> TRUE .)
    MINUS           reduce using rule 52 (factor -> TRUE .)
    AND             reduce using rule 52 (factor -> TRUE .)
    OR              reduce using rule 52 (factor -> TRUE .)
    EQUALS          reduce using rule 52 (factor -> TRUE .)
    NOT_EQUALS      reduce using rule 52 (factor -> TRUE .)
    LESS_THAN       reduce using rule 52 (factor -> TRUE .)
    LESS_THAN_OR_EQUAL reduce using rule 52 (factor -> TRUE .)
    GREATER_THAN    reduce using rule 52 (factor -> TRUE .)
    GREATER_THAN_OR_EQUAL reduce using rule 52 (factor -> TRUE .)
    RPAREN          reduce using rule 52 (factor -> TRUE .)
    RSQUARE         reduce using rule 52 (factor -> TRUE .)
    COMMA           reduce using rule 52 (factor -> TRUE .)


state 65

    (53) factor -> FALSE .

    TIMES           reduce using rule 53 (factor -> FALSE .)
    DIVIDE          reduce using rule 53 (factor -> FALSE .)
    SEMICOLON       reduce using rule 53 (factor -> FALSE .)
    PLUS            reduce using rule 53 (factor -> FALSE .)
    MINUS           reduce using rule 53 (factor -> FALSE .)
    AND             reduce using rule 53 (factor -> FALSE .)
    OR              reduce using rule 53 (factor -> FALSE .)
    EQUALS          reduce using rule 53 (factor -> FALSE .)
    NOT_EQUALS      reduce using rule 53 (factor -> FALSE .)
    LESS_THAN       reduce using rule 53 (factor -> FALSE .)
    LESS_THAN_OR_EQUAL reduce using rule 53 (factor -> FALSE .)
    GREATER_THAN    reduce using rule 53 (factor -> FALSE .)
    GREATER_THAN_OR_EQUAL reduce using rule 53 (factor -> FALSE .)
    RPAREN          reduce using rule 53 (factor -> FALSE .)
    RSQUARE         reduce using rule 53 (factor -> FALSE .)
    COMMA           reduce using rule 53 (factor -> FALSE .)


state 66

    (54) factor -> STRING_LITERAL .

    TIMES           reduce using rule 54 (factor -> STRING_LITERAL .)
    DIVIDE          reduce using rule 54 (factor -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 54 (factor -> STRING_LITERAL .)
    PLUS            reduce using rule 54 (factor -> STRING_LITERAL .)
    MINUS           reduce using rule 54 (factor -> STRING_LITERAL .)
    AND             reduce using rule 54 (factor -> STRING_LITERAL .)
    OR              reduce using rule 54 (factor -> STRING_LITERAL .)
    EQUALS          reduce using rule 54 (factor -> STRING_LITERAL .)
    NOT_EQUALS      reduce using rule 54 (factor -> STRING_LITERAL .)
    LESS_THAN       reduce using rule 54 (factor -> STRING_LITERAL .)
    LESS_THAN_OR_EQUAL reduce using rule 54 (factor -> STRING_LITERAL .)
    GREATER_THAN    reduce using rule 54 (factor -> STRING_LITERAL .)
    GREATER_THAN_OR_EQUAL reduce using rule 54 (factor -> STRING_LITERAL .)
    RPAREN          reduce using rule 54 (factor -> STRING_LITERAL .)
    RSQUARE         reduce using rule 54 (factor -> STRING_LITERAL .)
    COMMA           reduce using rule 54 (factor -> STRING_LITERAL .)


state 67

    (62) factor -> LPAREN . expr RPAREN
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 116
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 68

    (60) factor -> NEW . ID LPAREN RPAREN
    (61) factor -> NEW . INT LSQUARE expr RSQUARE

    ID              shift and go to state 117
    INT             shift and go to state 118


state 69

    (6) class_decl -> CLASS ID EXTENDS ID LBRACE . body RBRACE
    (25) body -> . var_decl body
    (26) body -> . method_decl body
    (27) body -> . statement body
    (28) body -> . empty
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (17) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (20) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (21) method_decl -> . PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (94) empty -> .
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    PUBLIC          shift and go to state 44
    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 35
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    RBRACE          reduce using rule 94 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    FOR             shift and go to state 53

    body                           shift and go to state 119
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42
    access_modifier                shift and go to state 43
    for_loop                       shift and go to state 52

state 70

    (80) statement -> ID EQUALS . expr SEMICOLON
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 120
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 71

    (81) statement -> ID LSQUARE . expr RSQUARE EQUALS expr SEMICOLON
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 121
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 72

    (82) statement -> ID DOT . ID EQUALS expr SEMICOLON
    (83) statement -> ID DOT . ID LPAREN args RPAREN SEMICOLON

    ID              shift and go to state 122


state 73

    (84) statement -> ID LPAREN . args RPAREN SEMICOLON
    (63) args -> . expr
    (64) args -> . expr COMMA args
    (65) args -> . empty
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (94) empty -> .
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    RPAREN          reduce using rule 94 (empty -> .)
    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    args                           shift and go to state 123
    expr                           shift and go to state 124
    empty                          shift and go to state 125
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 74

    (87) statement -> ID PLUS_PLUS . SEMICOLON

    SEMICOLON       shift and go to state 126


state 75

    (88) statement -> ID MINUS_MINUS . SEMICOLON

    SEMICOLON       shift and go to state 127


state 76

    (75) statement -> LBRACE body . RBRACE

    RBRACE          shift and go to state 128


state 77

    (7) class_decl -> CLASS ID LBRACE body RBRACE .

    CLASS           reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    IMPORT          reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    PUBLIC          reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    PRIVATE         reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    PROTECTED       reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    INT             reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    STRING          reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    ID              reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    VOID            reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    $end            reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)


state 78

    (25) body -> var_decl body .

    RBRACE          reduce using rule 25 (body -> var_decl body .)


state 79

    (26) body -> method_decl body .

    RBRACE          reduce using rule 26 (body -> method_decl body .)


state 80

    (27) body -> statement body .

    RBRACE          reduce using rule 27 (body -> statement body .)


state 81

    (15) var_decl -> type ID . SEMICOLON
    (16) var_decl -> type ID . EQUAL expr SEMICOLON
    (17) method_decl -> type ID . LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> type ID . LPAREN RPAREN LBRACE body RBRACE

    SEMICOLON       shift and go to state 31
    EQUAL           shift and go to state 32
    LPAREN          shift and go to state 129


state 82

    (18) method_decl -> access_modifier type . ID LPAREN params RPAREN LBRACE body RBRACE
    (34) type -> type . LSQUARE RSQUARE

    ID              shift and go to state 130
    LSQUARE         shift and go to state 26


state 83

    (20) method_decl -> access_modifier STATIC . type ID LPAREN params RPAREN LBRACE body RBRACE
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

    type                           shift and go to state 131

state 84

    (21) method_decl -> PUBLIC STATIC . VOID MAIN LPAREN params RPAREN LBRACE body RBRACE

    VOID            shift and go to state 132


state 85

    (76) statement -> IF LPAREN . expr RPAREN statement ELSE statement
    (77) statement -> IF LPAREN . expr RPAREN statement
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 133
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 86

    (78) statement -> WHILE LPAREN . expr RPAREN statement
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 134
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 87

    (79) statement -> SYSTEM DOT . OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON

    OUT             shift and go to state 135


state 88

    (85) statement -> RETURN expr . SEMICOLON
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    SEMICOLON       shift and go to state 136
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 89

    (86) statement -> RETURN SEMICOLON .

    PUBLIC          reduce using rule 86 (statement -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 86 (statement -> RETURN SEMICOLON .)
    IF              reduce using rule 86 (statement -> RETURN SEMICOLON .)
    WHILE           reduce using rule 86 (statement -> RETURN SEMICOLON .)
    SYSTEM          reduce using rule 86 (statement -> RETURN SEMICOLON .)
    ID              reduce using rule 86 (statement -> RETURN SEMICOLON .)
    RETURN          reduce using rule 86 (statement -> RETURN SEMICOLON .)
    PLUS_PLUS       reduce using rule 86 (statement -> RETURN SEMICOLON .)
    MINUS_MINUS     reduce using rule 86 (statement -> RETURN SEMICOLON .)
    THIS            reduce using rule 86 (statement -> RETURN SEMICOLON .)
    INT             reduce using rule 86 (statement -> RETURN SEMICOLON .)
    BOOLEAN         reduce using rule 86 (statement -> RETURN SEMICOLON .)
    STRING          reduce using rule 86 (statement -> RETURN SEMICOLON .)
    VOID            reduce using rule 86 (statement -> RETURN SEMICOLON .)
    PRIVATE         reduce using rule 86 (statement -> RETURN SEMICOLON .)
    PROTECTED       reduce using rule 86 (statement -> RETURN SEMICOLON .)
    FOR             reduce using rule 86 (statement -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 86 (statement -> RETURN SEMICOLON .)
    ELSE            reduce using rule 86 (statement -> RETURN SEMICOLON .)


state 90

    (89) statement -> PLUS_PLUS ID . SEMICOLON

    SEMICOLON       shift and go to state 137


state 91

    (90) statement -> MINUS_MINUS ID . SEMICOLON

    SEMICOLON       shift and go to state 138


state 92

    (91) statement -> THIS DOT . ID EQUAL expr SEMICOLON
    (92) statement -> THIS DOT . ID LPAREN args RPAREN SEMICOLON

    ID              shift and go to state 139


state 93

    (66) for_loop -> FOR LPAREN . var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> FOR LPAREN . SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> FOR LPAREN . var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> FOR LPAREN . SEMICOLON expr SEMICOLON increment_expr RPAREN statement
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE

    SEMICOLON       shift and go to state 141
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

    var_decl                       shift and go to state 140
    type                           shift and go to state 11

state 94

    (8) class_decl -> access_modifier CLASS ID EXTENDS ID . LBRACE body RBRACE

    LBRACE          shift and go to state 142


state 95

    (9) class_decl -> access_modifier CLASS ID LBRACE body . RBRACE

    RBRACE          shift and go to state 143


state 96

    (14) import_decl -> IMPORT ID DOT ID DOT . ID SEMICOLON

    ID              shift and go to state 144


state 97

    (13) import_decl -> IMPORT ID DOT ID SEMICOLON .

    CLASS           reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    IMPORT          reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    PUBLIC          reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    PRIVATE         reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    PROTECTED       reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    INT             reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    BOOLEAN         reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    STRING          reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    ID              reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    VOID            reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    $end            reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)


state 98

    (56) factor -> ID LSQUARE . expr RSQUARE
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 145
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 99

    (57) factor -> ID DOT . ID
    (58) factor -> ID DOT . ID LPAREN args RPAREN

    ID              shift and go to state 146


state 100

    (59) factor -> ID LPAREN . args RPAREN
    (63) args -> . expr
    (64) args -> . expr COMMA args
    (65) args -> . empty
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (94) empty -> .
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    RPAREN          reduce using rule 94 (empty -> .)
    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    args                           shift and go to state 147
    expr                           shift and go to state 124
    empty                          shift and go to state 125
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 101

    (16) var_decl -> type ID EQUAL expr SEMICOLON .

    CLASS           reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    IMPORT          reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    PUBLIC          reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    PRIVATE         reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    PROTECTED       reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    INT             reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    BOOLEAN         reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    STRING          reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    ID              reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    VOID            reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    $end            reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    LBRACE          reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    IF              reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    WHILE           reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    SYSTEM          reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    RETURN          reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    THIS            reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    FOR             reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    RBRACE          reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    MINUS           reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    NOT             reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    INT_LITERAL     reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    TRUE            reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    FALSE           reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    STRING_LITERAL  reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    NEW             reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)
    LPAREN          reduce using rule 16 (var_decl -> type ID EQUAL expr SEMICOLON .)


state 102

    (35) expr -> expr PLUS . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    term                           shift and go to state 148
    factor                         shift and go to state 61

state 103

    (36) expr -> expr MINUS . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    term                           shift and go to state 149
    factor                         shift and go to state 61

state 104

    (37) expr -> expr AND . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    term                           shift and go to state 150
    factor                         shift and go to state 61

state 105

    (38) expr -> expr OR . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    term                           shift and go to state 151
    factor                         shift and go to state 61

state 106

    (39) expr -> expr EQUALS . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    term                           shift and go to state 152
    factor                         shift and go to state 61

state 107

    (40) expr -> expr NOT_EQUALS . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    term                           shift and go to state 153
    factor                         shift and go to state 61

state 108

    (41) expr -> expr LESS_THAN . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    term                           shift and go to state 154
    factor                         shift and go to state 61

state 109

    (42) expr -> expr LESS_THAN_OR_EQUAL . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    term                           shift and go to state 155
    factor                         shift and go to state 61

state 110

    (43) expr -> expr GREATER_THAN . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    term                           shift and go to state 156
    factor                         shift and go to state 61

state 111

    (44) expr -> expr GREATER_THAN_OR_EQUAL . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    term                           shift and go to state 157
    factor                         shift and go to state 61

state 112

    (46) term -> term TIMES . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    factor                         shift and go to state 158

state 113

    (47) term -> term DIVIDE . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    factor                         shift and go to state 159

state 114

    (49) factor -> MINUS factor .

    TIMES           reduce using rule 49 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 49 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 49 (factor -> MINUS factor .)
    PLUS            reduce using rule 49 (factor -> MINUS factor .)
    MINUS           reduce using rule 49 (factor -> MINUS factor .)
    AND             reduce using rule 49 (factor -> MINUS factor .)
    OR              reduce using rule 49 (factor -> MINUS factor .)
    EQUALS          reduce using rule 49 (factor -> MINUS factor .)
    NOT_EQUALS      reduce using rule 49 (factor -> MINUS factor .)
    LESS_THAN       reduce using rule 49 (factor -> MINUS factor .)
    LESS_THAN_OR_EQUAL reduce using rule 49 (factor -> MINUS factor .)
    GREATER_THAN    reduce using rule 49 (factor -> MINUS factor .)
    GREATER_THAN_OR_EQUAL reduce using rule 49 (factor -> MINUS factor .)
    RPAREN          reduce using rule 49 (factor -> MINUS factor .)
    RSQUARE         reduce using rule 49 (factor -> MINUS factor .)
    COMMA           reduce using rule 49 (factor -> MINUS factor .)


state 115

    (50) factor -> NOT factor .

    TIMES           reduce using rule 50 (factor -> NOT factor .)
    DIVIDE          reduce using rule 50 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 50 (factor -> NOT factor .)
    PLUS            reduce using rule 50 (factor -> NOT factor .)
    MINUS           reduce using rule 50 (factor -> NOT factor .)
    AND             reduce using rule 50 (factor -> NOT factor .)
    OR              reduce using rule 50 (factor -> NOT factor .)
    EQUALS          reduce using rule 50 (factor -> NOT factor .)
    NOT_EQUALS      reduce using rule 50 (factor -> NOT factor .)
    LESS_THAN       reduce using rule 50 (factor -> NOT factor .)
    LESS_THAN_OR_EQUAL reduce using rule 50 (factor -> NOT factor .)
    GREATER_THAN    reduce using rule 50 (factor -> NOT factor .)
    GREATER_THAN_OR_EQUAL reduce using rule 50 (factor -> NOT factor .)
    RPAREN          reduce using rule 50 (factor -> NOT factor .)
    RSQUARE         reduce using rule 50 (factor -> NOT factor .)
    COMMA           reduce using rule 50 (factor -> NOT factor .)


state 116

    (62) factor -> LPAREN expr . RPAREN
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    RPAREN          shift and go to state 160
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 117

    (60) factor -> NEW ID . LPAREN RPAREN

    LPAREN          shift and go to state 161


state 118

    (61) factor -> NEW INT . LSQUARE expr RSQUARE

    LSQUARE         shift and go to state 162


state 119

    (6) class_decl -> CLASS ID EXTENDS ID LBRACE body . RBRACE

    RBRACE          shift and go to state 163


state 120

    (80) statement -> ID EQUALS expr . SEMICOLON
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    SEMICOLON       shift and go to state 164
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 121

    (81) statement -> ID LSQUARE expr . RSQUARE EQUALS expr SEMICOLON
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    RSQUARE         shift and go to state 165
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 122

    (82) statement -> ID DOT ID . EQUALS expr SEMICOLON
    (83) statement -> ID DOT ID . LPAREN args RPAREN SEMICOLON

    EQUALS          shift and go to state 166
    LPAREN          shift and go to state 167


state 123

    (84) statement -> ID LPAREN args . RPAREN SEMICOLON

    RPAREN          shift and go to state 168


state 124

    (63) args -> expr .
    (64) args -> expr . COMMA args
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    RPAREN          reduce using rule 63 (args -> expr .)
    COMMA           shift and go to state 169
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 125

    (65) args -> empty .

    RPAREN          reduce using rule 65 (args -> empty .)


state 126

    (87) statement -> ID PLUS_PLUS SEMICOLON .

    PUBLIC          reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    LBRACE          reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    IF              reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    WHILE           reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    SYSTEM          reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    ID              reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    RETURN          reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    PLUS_PLUS       reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    MINUS_MINUS     reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    THIS            reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    INT             reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    BOOLEAN         reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    STRING          reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    VOID            reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    PRIVATE         reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    PROTECTED       reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    FOR             reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    RBRACE          reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)
    ELSE            reduce using rule 87 (statement -> ID PLUS_PLUS SEMICOLON .)


state 127

    (88) statement -> ID MINUS_MINUS SEMICOLON .

    PUBLIC          reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    LBRACE          reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    IF              reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    WHILE           reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    SYSTEM          reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    ID              reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    RETURN          reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    PLUS_PLUS       reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    MINUS_MINUS     reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    THIS            reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    INT             reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    BOOLEAN         reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    STRING          reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    VOID            reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    PRIVATE         reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    PROTECTED       reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    FOR             reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    RBRACE          reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)
    ELSE            reduce using rule 88 (statement -> ID MINUS_MINUS SEMICOLON .)


state 128

    (75) statement -> LBRACE body RBRACE .

    PUBLIC          reduce using rule 75 (statement -> LBRACE body RBRACE .)
    LBRACE          reduce using rule 75 (statement -> LBRACE body RBRACE .)
    IF              reduce using rule 75 (statement -> LBRACE body RBRACE .)
    WHILE           reduce using rule 75 (statement -> LBRACE body RBRACE .)
    SYSTEM          reduce using rule 75 (statement -> LBRACE body RBRACE .)
    ID              reduce using rule 75 (statement -> LBRACE body RBRACE .)
    RETURN          reduce using rule 75 (statement -> LBRACE body RBRACE .)
    PLUS_PLUS       reduce using rule 75 (statement -> LBRACE body RBRACE .)
    MINUS_MINUS     reduce using rule 75 (statement -> LBRACE body RBRACE .)
    THIS            reduce using rule 75 (statement -> LBRACE body RBRACE .)
    INT             reduce using rule 75 (statement -> LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 75 (statement -> LBRACE body RBRACE .)
    STRING          reduce using rule 75 (statement -> LBRACE body RBRACE .)
    VOID            reduce using rule 75 (statement -> LBRACE body RBRACE .)
    PRIVATE         reduce using rule 75 (statement -> LBRACE body RBRACE .)
    PROTECTED       reduce using rule 75 (statement -> LBRACE body RBRACE .)
    FOR             reduce using rule 75 (statement -> LBRACE body RBRACE .)
    RBRACE          reduce using rule 75 (statement -> LBRACE body RBRACE .)
    ELSE            reduce using rule 75 (statement -> LBRACE body RBRACE .)


state 129

    (17) method_decl -> type ID LPAREN . params RPAREN LBRACE body RBRACE
    (19) method_decl -> type ID LPAREN . RPAREN LBRACE body RBRACE
    (22) params -> . type ID
    (23) params -> . type ID COMMA params
    (24) params -> . empty
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (94) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 172
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

  ! RPAREN          [ reduce using rule 94 (empty -> .) ]

    type                           shift and go to state 170
    params                         shift and go to state 171
    empty                          shift and go to state 173

state 130

    (18) method_decl -> access_modifier type ID . LPAREN params RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 174


state 131

    (20) method_decl -> access_modifier STATIC type . ID LPAREN params RPAREN LBRACE body RBRACE
    (34) type -> type . LSQUARE RSQUARE

    ID              shift and go to state 175
    LSQUARE         shift and go to state 26


state 132

    (21) method_decl -> PUBLIC STATIC VOID . MAIN LPAREN params RPAREN LBRACE body RBRACE

    MAIN            shift and go to state 176


state 133

    (76) statement -> IF LPAREN expr . RPAREN statement ELSE statement
    (77) statement -> IF LPAREN expr . RPAREN statement
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    RPAREN          shift and go to state 177
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 134

    (78) statement -> WHILE LPAREN expr . RPAREN statement
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    RPAREN          shift and go to state 178
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 135

    (79) statement -> SYSTEM DOT OUT . DOT PRINTLN LPAREN expr RPAREN SEMICOLON

    DOT             shift and go to state 179


state 136

    (85) statement -> RETURN expr SEMICOLON .

    PUBLIC          reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    IF              reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    SYSTEM          reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    ID              reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    THIS            reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    INT             reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    BOOLEAN         reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    STRING          reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    VOID            reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    PRIVATE         reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    PROTECTED       reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    RBRACE          reduce using rule 85 (statement -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 85 (statement -> RETURN expr SEMICOLON .)


state 137

    (89) statement -> PLUS_PLUS ID SEMICOLON .

    PUBLIC          reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    LBRACE          reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    IF              reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    WHILE           reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    SYSTEM          reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    ID              reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    RETURN          reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    THIS            reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    INT             reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    BOOLEAN         reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    STRING          reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    VOID            reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    PRIVATE         reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    PROTECTED       reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    FOR             reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    RBRACE          reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)
    ELSE            reduce using rule 89 (statement -> PLUS_PLUS ID SEMICOLON .)


state 138

    (90) statement -> MINUS_MINUS ID SEMICOLON .

    PUBLIC          reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    LBRACE          reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    IF              reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    WHILE           reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    SYSTEM          reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    ID              reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    RETURN          reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    THIS            reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    INT             reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    BOOLEAN         reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    STRING          reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    VOID            reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    PRIVATE         reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    PROTECTED       reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    FOR             reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    RBRACE          reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)
    ELSE            reduce using rule 90 (statement -> MINUS_MINUS ID SEMICOLON .)


state 139

    (91) statement -> THIS DOT ID . EQUAL expr SEMICOLON
    (92) statement -> THIS DOT ID . LPAREN args RPAREN SEMICOLON

    EQUAL           shift and go to state 180
    LPAREN          shift and go to state 181


state 140

    (66) for_loop -> FOR LPAREN var_decl . expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> FOR LPAREN var_decl . expr SEMICOLON increment_expr RPAREN statement
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 182
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 141

    (67) for_loop -> FOR LPAREN SEMICOLON . expr SEMICOLON assign_expr RPAREN statement
    (69) for_loop -> FOR LPAREN SEMICOLON . expr SEMICOLON increment_expr RPAREN statement
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 183
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 142

    (8) class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE . body RBRACE
    (25) body -> . var_decl body
    (26) body -> . method_decl body
    (27) body -> . statement body
    (28) body -> . empty
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (17) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (20) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (21) method_decl -> . PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (94) empty -> .
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    PUBLIC          shift and go to state 44
    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 35
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    RBRACE          reduce using rule 94 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    FOR             shift and go to state 53

    access_modifier                shift and go to state 43
    body                           shift and go to state 184
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42
    for_loop                       shift and go to state 52

state 143

    (9) class_decl -> access_modifier CLASS ID LBRACE body RBRACE .

    CLASS           reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    IMPORT          reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    PUBLIC          reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    PRIVATE         reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    PROTECTED       reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    INT             reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    STRING          reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    ID              reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    VOID            reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    $end            reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)


state 144

    (14) import_decl -> IMPORT ID DOT ID DOT ID . SEMICOLON

    SEMICOLON       shift and go to state 185


state 145

    (56) factor -> ID LSQUARE expr . RSQUARE
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    RSQUARE         shift and go to state 186
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 146

    (57) factor -> ID DOT ID .
    (58) factor -> ID DOT ID . LPAREN args RPAREN

    TIMES           reduce using rule 57 (factor -> ID DOT ID .)
    DIVIDE          reduce using rule 57 (factor -> ID DOT ID .)
    SEMICOLON       reduce using rule 57 (factor -> ID DOT ID .)
    PLUS            reduce using rule 57 (factor -> ID DOT ID .)
    MINUS           reduce using rule 57 (factor -> ID DOT ID .)
    AND             reduce using rule 57 (factor -> ID DOT ID .)
    OR              reduce using rule 57 (factor -> ID DOT ID .)
    EQUALS          reduce using rule 57 (factor -> ID DOT ID .)
    NOT_EQUALS      reduce using rule 57 (factor -> ID DOT ID .)
    LESS_THAN       reduce using rule 57 (factor -> ID DOT ID .)
    LESS_THAN_OR_EQUAL reduce using rule 57 (factor -> ID DOT ID .)
    GREATER_THAN    reduce using rule 57 (factor -> ID DOT ID .)
    GREATER_THAN_OR_EQUAL reduce using rule 57 (factor -> ID DOT ID .)
    RPAREN          reduce using rule 57 (factor -> ID DOT ID .)
    RSQUARE         reduce using rule 57 (factor -> ID DOT ID .)
    COMMA           reduce using rule 57 (factor -> ID DOT ID .)
    LPAREN          shift and go to state 187


state 147

    (59) factor -> ID LPAREN args . RPAREN

    RPAREN          shift and go to state 188


state 148

    (35) expr -> expr PLUS term .
    (46) term -> term . TIMES factor
    (47) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 35 (expr -> expr PLUS term .)
    PLUS            reduce using rule 35 (expr -> expr PLUS term .)
    MINUS           reduce using rule 35 (expr -> expr PLUS term .)
    AND             reduce using rule 35 (expr -> expr PLUS term .)
    OR              reduce using rule 35 (expr -> expr PLUS term .)
    EQUALS          reduce using rule 35 (expr -> expr PLUS term .)
    NOT_EQUALS      reduce using rule 35 (expr -> expr PLUS term .)
    LESS_THAN       reduce using rule 35 (expr -> expr PLUS term .)
    LESS_THAN_OR_EQUAL reduce using rule 35 (expr -> expr PLUS term .)
    GREATER_THAN    reduce using rule 35 (expr -> expr PLUS term .)
    GREATER_THAN_OR_EQUAL reduce using rule 35 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 35 (expr -> expr PLUS term .)
    RSQUARE         reduce using rule 35 (expr -> expr PLUS term .)
    COMMA           reduce using rule 35 (expr -> expr PLUS term .)
    TIMES           shift and go to state 112
    DIVIDE          shift and go to state 113


state 149

    (36) expr -> expr MINUS term .
    (46) term -> term . TIMES factor
    (47) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 36 (expr -> expr MINUS term .)
    PLUS            reduce using rule 36 (expr -> expr MINUS term .)
    MINUS           reduce using rule 36 (expr -> expr MINUS term .)
    AND             reduce using rule 36 (expr -> expr MINUS term .)
    OR              reduce using rule 36 (expr -> expr MINUS term .)
    EQUALS          reduce using rule 36 (expr -> expr MINUS term .)
    NOT_EQUALS      reduce using rule 36 (expr -> expr MINUS term .)
    LESS_THAN       reduce using rule 36 (expr -> expr MINUS term .)
    LESS_THAN_OR_EQUAL reduce using rule 36 (expr -> expr MINUS term .)
    GREATER_THAN    reduce using rule 36 (expr -> expr MINUS term .)
    GREATER_THAN_OR_EQUAL reduce using rule 36 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 36 (expr -> expr MINUS term .)
    RSQUARE         reduce using rule 36 (expr -> expr MINUS term .)
    COMMA           reduce using rule 36 (expr -> expr MINUS term .)
    TIMES           shift and go to state 112
    DIVIDE          shift and go to state 113


state 150

    (37) expr -> expr AND term .
    (46) term -> term . TIMES factor
    (47) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 37 (expr -> expr AND term .)
    PLUS            reduce using rule 37 (expr -> expr AND term .)
    MINUS           reduce using rule 37 (expr -> expr AND term .)
    AND             reduce using rule 37 (expr -> expr AND term .)
    OR              reduce using rule 37 (expr -> expr AND term .)
    EQUALS          reduce using rule 37 (expr -> expr AND term .)
    NOT_EQUALS      reduce using rule 37 (expr -> expr AND term .)
    LESS_THAN       reduce using rule 37 (expr -> expr AND term .)
    LESS_THAN_OR_EQUAL reduce using rule 37 (expr -> expr AND term .)
    GREATER_THAN    reduce using rule 37 (expr -> expr AND term .)
    GREATER_THAN_OR_EQUAL reduce using rule 37 (expr -> expr AND term .)
    RPAREN          reduce using rule 37 (expr -> expr AND term .)
    RSQUARE         reduce using rule 37 (expr -> expr AND term .)
    COMMA           reduce using rule 37 (expr -> expr AND term .)
    TIMES           shift and go to state 112
    DIVIDE          shift and go to state 113


state 151

    (38) expr -> expr OR term .
    (46) term -> term . TIMES factor
    (47) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 38 (expr -> expr OR term .)
    PLUS            reduce using rule 38 (expr -> expr OR term .)
    MINUS           reduce using rule 38 (expr -> expr OR term .)
    AND             reduce using rule 38 (expr -> expr OR term .)
    OR              reduce using rule 38 (expr -> expr OR term .)
    EQUALS          reduce using rule 38 (expr -> expr OR term .)
    NOT_EQUALS      reduce using rule 38 (expr -> expr OR term .)
    LESS_THAN       reduce using rule 38 (expr -> expr OR term .)
    LESS_THAN_OR_EQUAL reduce using rule 38 (expr -> expr OR term .)
    GREATER_THAN    reduce using rule 38 (expr -> expr OR term .)
    GREATER_THAN_OR_EQUAL reduce using rule 38 (expr -> expr OR term .)
    RPAREN          reduce using rule 38 (expr -> expr OR term .)
    RSQUARE         reduce using rule 38 (expr -> expr OR term .)
    COMMA           reduce using rule 38 (expr -> expr OR term .)
    TIMES           shift and go to state 112
    DIVIDE          shift and go to state 113


state 152

    (39) expr -> expr EQUALS term .
    (46) term -> term . TIMES factor
    (47) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 39 (expr -> expr EQUALS term .)
    PLUS            reduce using rule 39 (expr -> expr EQUALS term .)
    MINUS           reduce using rule 39 (expr -> expr EQUALS term .)
    AND             reduce using rule 39 (expr -> expr EQUALS term .)
    OR              reduce using rule 39 (expr -> expr EQUALS term .)
    EQUALS          reduce using rule 39 (expr -> expr EQUALS term .)
    NOT_EQUALS      reduce using rule 39 (expr -> expr EQUALS term .)
    LESS_THAN       reduce using rule 39 (expr -> expr EQUALS term .)
    LESS_THAN_OR_EQUAL reduce using rule 39 (expr -> expr EQUALS term .)
    GREATER_THAN    reduce using rule 39 (expr -> expr EQUALS term .)
    GREATER_THAN_OR_EQUAL reduce using rule 39 (expr -> expr EQUALS term .)
    RPAREN          reduce using rule 39 (expr -> expr EQUALS term .)
    RSQUARE         reduce using rule 39 (expr -> expr EQUALS term .)
    COMMA           reduce using rule 39 (expr -> expr EQUALS term .)
    TIMES           shift and go to state 112
    DIVIDE          shift and go to state 113


state 153

    (40) expr -> expr NOT_EQUALS term .
    (46) term -> term . TIMES factor
    (47) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 40 (expr -> expr NOT_EQUALS term .)
    PLUS            reduce using rule 40 (expr -> expr NOT_EQUALS term .)
    MINUS           reduce using rule 40 (expr -> expr NOT_EQUALS term .)
    AND             reduce using rule 40 (expr -> expr NOT_EQUALS term .)
    OR              reduce using rule 40 (expr -> expr NOT_EQUALS term .)
    EQUALS          reduce using rule 40 (expr -> expr NOT_EQUALS term .)
    NOT_EQUALS      reduce using rule 40 (expr -> expr NOT_EQUALS term .)
    LESS_THAN       reduce using rule 40 (expr -> expr NOT_EQUALS term .)
    LESS_THAN_OR_EQUAL reduce using rule 40 (expr -> expr NOT_EQUALS term .)
    GREATER_THAN    reduce using rule 40 (expr -> expr NOT_EQUALS term .)
    GREATER_THAN_OR_EQUAL reduce using rule 40 (expr -> expr NOT_EQUALS term .)
    RPAREN          reduce using rule 40 (expr -> expr NOT_EQUALS term .)
    RSQUARE         reduce using rule 40 (expr -> expr NOT_EQUALS term .)
    COMMA           reduce using rule 40 (expr -> expr NOT_EQUALS term .)
    TIMES           shift and go to state 112
    DIVIDE          shift and go to state 113


state 154

    (41) expr -> expr LESS_THAN term .
    (46) term -> term . TIMES factor
    (47) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 41 (expr -> expr LESS_THAN term .)
    PLUS            reduce using rule 41 (expr -> expr LESS_THAN term .)
    MINUS           reduce using rule 41 (expr -> expr LESS_THAN term .)
    AND             reduce using rule 41 (expr -> expr LESS_THAN term .)
    OR              reduce using rule 41 (expr -> expr LESS_THAN term .)
    EQUALS          reduce using rule 41 (expr -> expr LESS_THAN term .)
    NOT_EQUALS      reduce using rule 41 (expr -> expr LESS_THAN term .)
    LESS_THAN       reduce using rule 41 (expr -> expr LESS_THAN term .)
    LESS_THAN_OR_EQUAL reduce using rule 41 (expr -> expr LESS_THAN term .)
    GREATER_THAN    reduce using rule 41 (expr -> expr LESS_THAN term .)
    GREATER_THAN_OR_EQUAL reduce using rule 41 (expr -> expr LESS_THAN term .)
    RPAREN          reduce using rule 41 (expr -> expr LESS_THAN term .)
    RSQUARE         reduce using rule 41 (expr -> expr LESS_THAN term .)
    COMMA           reduce using rule 41 (expr -> expr LESS_THAN term .)
    TIMES           shift and go to state 112
    DIVIDE          shift and go to state 113


state 155

    (42) expr -> expr LESS_THAN_OR_EQUAL term .
    (46) term -> term . TIMES factor
    (47) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 42 (expr -> expr LESS_THAN_OR_EQUAL term .)
    PLUS            reduce using rule 42 (expr -> expr LESS_THAN_OR_EQUAL term .)
    MINUS           reduce using rule 42 (expr -> expr LESS_THAN_OR_EQUAL term .)
    AND             reduce using rule 42 (expr -> expr LESS_THAN_OR_EQUAL term .)
    OR              reduce using rule 42 (expr -> expr LESS_THAN_OR_EQUAL term .)
    EQUALS          reduce using rule 42 (expr -> expr LESS_THAN_OR_EQUAL term .)
    NOT_EQUALS      reduce using rule 42 (expr -> expr LESS_THAN_OR_EQUAL term .)
    LESS_THAN       reduce using rule 42 (expr -> expr LESS_THAN_OR_EQUAL term .)
    LESS_THAN_OR_EQUAL reduce using rule 42 (expr -> expr LESS_THAN_OR_EQUAL term .)
    GREATER_THAN    reduce using rule 42 (expr -> expr LESS_THAN_OR_EQUAL term .)
    GREATER_THAN_OR_EQUAL reduce using rule 42 (expr -> expr LESS_THAN_OR_EQUAL term .)
    RPAREN          reduce using rule 42 (expr -> expr LESS_THAN_OR_EQUAL term .)
    RSQUARE         reduce using rule 42 (expr -> expr LESS_THAN_OR_EQUAL term .)
    COMMA           reduce using rule 42 (expr -> expr LESS_THAN_OR_EQUAL term .)
    TIMES           shift and go to state 112
    DIVIDE          shift and go to state 113


state 156

    (43) expr -> expr GREATER_THAN term .
    (46) term -> term . TIMES factor
    (47) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 43 (expr -> expr GREATER_THAN term .)
    PLUS            reduce using rule 43 (expr -> expr GREATER_THAN term .)
    MINUS           reduce using rule 43 (expr -> expr GREATER_THAN term .)
    AND             reduce using rule 43 (expr -> expr GREATER_THAN term .)
    OR              reduce using rule 43 (expr -> expr GREATER_THAN term .)
    EQUALS          reduce using rule 43 (expr -> expr GREATER_THAN term .)
    NOT_EQUALS      reduce using rule 43 (expr -> expr GREATER_THAN term .)
    LESS_THAN       reduce using rule 43 (expr -> expr GREATER_THAN term .)
    LESS_THAN_OR_EQUAL reduce using rule 43 (expr -> expr GREATER_THAN term .)
    GREATER_THAN    reduce using rule 43 (expr -> expr GREATER_THAN term .)
    GREATER_THAN_OR_EQUAL reduce using rule 43 (expr -> expr GREATER_THAN term .)
    RPAREN          reduce using rule 43 (expr -> expr GREATER_THAN term .)
    RSQUARE         reduce using rule 43 (expr -> expr GREATER_THAN term .)
    COMMA           reduce using rule 43 (expr -> expr GREATER_THAN term .)
    TIMES           shift and go to state 112
    DIVIDE          shift and go to state 113


state 157

    (44) expr -> expr GREATER_THAN_OR_EQUAL term .
    (46) term -> term . TIMES factor
    (47) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 44 (expr -> expr GREATER_THAN_OR_EQUAL term .)
    PLUS            reduce using rule 44 (expr -> expr GREATER_THAN_OR_EQUAL term .)
    MINUS           reduce using rule 44 (expr -> expr GREATER_THAN_OR_EQUAL term .)
    AND             reduce using rule 44 (expr -> expr GREATER_THAN_OR_EQUAL term .)
    OR              reduce using rule 44 (expr -> expr GREATER_THAN_OR_EQUAL term .)
    EQUALS          reduce using rule 44 (expr -> expr GREATER_THAN_OR_EQUAL term .)
    NOT_EQUALS      reduce using rule 44 (expr -> expr GREATER_THAN_OR_EQUAL term .)
    LESS_THAN       reduce using rule 44 (expr -> expr GREATER_THAN_OR_EQUAL term .)
    LESS_THAN_OR_EQUAL reduce using rule 44 (expr -> expr GREATER_THAN_OR_EQUAL term .)
    GREATER_THAN    reduce using rule 44 (expr -> expr GREATER_THAN_OR_EQUAL term .)
    GREATER_THAN_OR_EQUAL reduce using rule 44 (expr -> expr GREATER_THAN_OR_EQUAL term .)
    RPAREN          reduce using rule 44 (expr -> expr GREATER_THAN_OR_EQUAL term .)
    RSQUARE         reduce using rule 44 (expr -> expr GREATER_THAN_OR_EQUAL term .)
    COMMA           reduce using rule 44 (expr -> expr GREATER_THAN_OR_EQUAL term .)
    TIMES           shift and go to state 112
    DIVIDE          shift and go to state 113


state 158

    (46) term -> term TIMES factor .

    TIMES           reduce using rule 46 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 46 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 46 (term -> term TIMES factor .)
    PLUS            reduce using rule 46 (term -> term TIMES factor .)
    MINUS           reduce using rule 46 (term -> term TIMES factor .)
    AND             reduce using rule 46 (term -> term TIMES factor .)
    OR              reduce using rule 46 (term -> term TIMES factor .)
    EQUALS          reduce using rule 46 (term -> term TIMES factor .)
    NOT_EQUALS      reduce using rule 46 (term -> term TIMES factor .)
    LESS_THAN       reduce using rule 46 (term -> term TIMES factor .)
    LESS_THAN_OR_EQUAL reduce using rule 46 (term -> term TIMES factor .)
    GREATER_THAN    reduce using rule 46 (term -> term TIMES factor .)
    GREATER_THAN_OR_EQUAL reduce using rule 46 (term -> term TIMES factor .)
    RPAREN          reduce using rule 46 (term -> term TIMES factor .)
    RSQUARE         reduce using rule 46 (term -> term TIMES factor .)
    COMMA           reduce using rule 46 (term -> term TIMES factor .)


state 159

    (47) term -> term DIVIDE factor .

    TIMES           reduce using rule 47 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 47 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 47 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 47 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 47 (term -> term DIVIDE factor .)
    AND             reduce using rule 47 (term -> term DIVIDE factor .)
    OR              reduce using rule 47 (term -> term DIVIDE factor .)
    EQUALS          reduce using rule 47 (term -> term DIVIDE factor .)
    NOT_EQUALS      reduce using rule 47 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 47 (term -> term DIVIDE factor .)
    LESS_THAN_OR_EQUAL reduce using rule 47 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 47 (term -> term DIVIDE factor .)
    GREATER_THAN_OR_EQUAL reduce using rule 47 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 47 (term -> term DIVIDE factor .)
    RSQUARE         reduce using rule 47 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 47 (term -> term DIVIDE factor .)


state 160

    (62) factor -> LPAREN expr RPAREN .

    TIMES           reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    AND             reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    OR              reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    EQUALS          reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    NOT_EQUALS      reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    LESS_THAN       reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    LESS_THAN_OR_EQUAL reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    GREATER_THAN    reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    GREATER_THAN_OR_EQUAL reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    RSQUARE         reduce using rule 62 (factor -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 62 (factor -> LPAREN expr RPAREN .)


state 161

    (60) factor -> NEW ID LPAREN . RPAREN

    RPAREN          shift and go to state 189


state 162

    (61) factor -> NEW INT LSQUARE . expr RSQUARE
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 190
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 163

    (6) class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .

    CLASS           reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    IMPORT          reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    PUBLIC          reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    PRIVATE         reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    PROTECTED       reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    INT             reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    STRING          reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    ID              reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    VOID            reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    $end            reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)


state 164

    (80) statement -> ID EQUALS expr SEMICOLON .

    PUBLIC          reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    LBRACE          reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    IF              reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    WHILE           reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    SYSTEM          reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    ID              reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    RETURN          reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    THIS            reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    INT             reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    BOOLEAN         reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    STRING          reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    VOID            reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    PRIVATE         reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    PROTECTED       reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    FOR             reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    RBRACE          reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)
    ELSE            reduce using rule 80 (statement -> ID EQUALS expr SEMICOLON .)


state 165

    (81) statement -> ID LSQUARE expr RSQUARE . EQUALS expr SEMICOLON

    EQUALS          shift and go to state 191


state 166

    (82) statement -> ID DOT ID EQUALS . expr SEMICOLON
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 192
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 167

    (83) statement -> ID DOT ID LPAREN . args RPAREN SEMICOLON
    (63) args -> . expr
    (64) args -> . expr COMMA args
    (65) args -> . empty
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (94) empty -> .
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    RPAREN          reduce using rule 94 (empty -> .)
    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    args                           shift and go to state 193
    expr                           shift and go to state 124
    empty                          shift and go to state 125
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 168

    (84) statement -> ID LPAREN args RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 194


state 169

    (64) args -> expr COMMA . args
    (63) args -> . expr
    (64) args -> . expr COMMA args
    (65) args -> . empty
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (94) empty -> .
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    RPAREN          reduce using rule 94 (empty -> .)
    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 124
    args                           shift and go to state 195
    empty                          shift and go to state 125
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 170

    (22) params -> type . ID
    (23) params -> type . ID COMMA params
    (34) type -> type . LSQUARE RSQUARE

    ID              shift and go to state 196
    LSQUARE         shift and go to state 26


state 171

    (17) method_decl -> type ID LPAREN params . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 197


state 172

    (19) method_decl -> type ID LPAREN RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 198


state 173

    (24) params -> empty .

    RPAREN          reduce using rule 24 (params -> empty .)


state 174

    (18) method_decl -> access_modifier type ID LPAREN . params RPAREN LBRACE body RBRACE
    (22) params -> . type ID
    (23) params -> . type ID COMMA params
    (24) params -> . empty
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (94) empty -> .

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18
    RPAREN          reduce using rule 94 (empty -> .)

    type                           shift and go to state 170
    params                         shift and go to state 199
    empty                          shift and go to state 173

state 175

    (20) method_decl -> access_modifier STATIC type ID . LPAREN params RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 200


state 176

    (21) method_decl -> PUBLIC STATIC VOID MAIN . LPAREN params RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 201


state 177

    (76) statement -> IF LPAREN expr RPAREN . statement ELSE statement
    (77) statement -> IF LPAREN expr RPAREN . statement
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 203
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    FOR             shift and go to state 53

    statement                      shift and go to state 202
    for_loop                       shift and go to state 52

state 178

    (78) statement -> WHILE LPAREN expr RPAREN . statement
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 203
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    FOR             shift and go to state 53

    statement                      shift and go to state 204
    for_loop                       shift and go to state 52

state 179

    (79) statement -> SYSTEM DOT OUT DOT . PRINTLN LPAREN expr RPAREN SEMICOLON

    PRINTLN         shift and go to state 205


state 180

    (91) statement -> THIS DOT ID EQUAL . expr SEMICOLON
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 206
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 181

    (92) statement -> THIS DOT ID LPAREN . args RPAREN SEMICOLON
    (63) args -> . expr
    (64) args -> . expr COMMA args
    (65) args -> . empty
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (94) empty -> .
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    RPAREN          reduce using rule 94 (empty -> .)
    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    args                           shift and go to state 207
    expr                           shift and go to state 124
    empty                          shift and go to state 125
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 182

    (66) for_loop -> FOR LPAREN var_decl expr . SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> FOR LPAREN var_decl expr . SEMICOLON increment_expr RPAREN statement
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    SEMICOLON       shift and go to state 208
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 183

    (67) for_loop -> FOR LPAREN SEMICOLON expr . SEMICOLON assign_expr RPAREN statement
    (69) for_loop -> FOR LPAREN SEMICOLON expr . SEMICOLON increment_expr RPAREN statement
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    SEMICOLON       shift and go to state 209
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 184

    (8) class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body . RBRACE

    RBRACE          shift and go to state 210


state 185

    (14) import_decl -> IMPORT ID DOT ID DOT ID SEMICOLON .

    CLASS           reduce using rule 14 (import_decl -> IMPORT ID DOT ID DOT ID SEMICOLON .)
    IMPORT          reduce using rule 14 (import_decl -> IMPORT ID DOT ID DOT ID SEMICOLON .)
    PUBLIC          reduce using rule 14 (import_decl -> IMPORT ID DOT ID DOT ID SEMICOLON .)
    PRIVATE         reduce using rule 14 (import_decl -> IMPORT ID DOT ID DOT ID SEMICOLON .)
    PROTECTED       reduce using rule 14 (import_decl -> IMPORT ID DOT ID DOT ID SEMICOLON .)
    INT             reduce using rule 14 (import_decl -> IMPORT ID DOT ID DOT ID SEMICOLON .)
    BOOLEAN         reduce using rule 14 (import_decl -> IMPORT ID DOT ID DOT ID SEMICOLON .)
    STRING          reduce using rule 14 (import_decl -> IMPORT ID DOT ID DOT ID SEMICOLON .)
    ID              reduce using rule 14 (import_decl -> IMPORT ID DOT ID DOT ID SEMICOLON .)
    VOID            reduce using rule 14 (import_decl -> IMPORT ID DOT ID DOT ID SEMICOLON .)
    $end            reduce using rule 14 (import_decl -> IMPORT ID DOT ID DOT ID SEMICOLON .)


state 186

    (56) factor -> ID LSQUARE expr RSQUARE .

    TIMES           reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    DIVIDE          reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    SEMICOLON       reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    PLUS            reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    MINUS           reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    AND             reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    OR              reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    EQUALS          reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    NOT_EQUALS      reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    LESS_THAN       reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    LESS_THAN_OR_EQUAL reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    GREATER_THAN    reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    GREATER_THAN_OR_EQUAL reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    RPAREN          reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    RSQUARE         reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)
    COMMA           reduce using rule 56 (factor -> ID LSQUARE expr RSQUARE .)


state 187

    (58) factor -> ID DOT ID LPAREN . args RPAREN
    (63) args -> . expr
    (64) args -> . expr COMMA args
    (65) args -> . empty
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (94) empty -> .
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    RPAREN          reduce using rule 94 (empty -> .)
    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    args                           shift and go to state 211
    expr                           shift and go to state 124
    empty                          shift and go to state 125
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 188

    (59) factor -> ID LPAREN args RPAREN .

    TIMES           reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    DIVIDE          reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    SEMICOLON       reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    PLUS            reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    MINUS           reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    AND             reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    OR              reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    EQUALS          reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    NOT_EQUALS      reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    LESS_THAN       reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    LESS_THAN_OR_EQUAL reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    GREATER_THAN    reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    GREATER_THAN_OR_EQUAL reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    RPAREN          reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    RSQUARE         reduce using rule 59 (factor -> ID LPAREN args RPAREN .)
    COMMA           reduce using rule 59 (factor -> ID LPAREN args RPAREN .)


state 189

    (60) factor -> NEW ID LPAREN RPAREN .

    TIMES           reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    PLUS            reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    MINUS           reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    AND             reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    OR              reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    EQUALS          reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    NOT_EQUALS      reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    LESS_THAN       reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    LESS_THAN_OR_EQUAL reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    GREATER_THAN    reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    GREATER_THAN_OR_EQUAL reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    RPAREN          reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    RSQUARE         reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)
    COMMA           reduce using rule 60 (factor -> NEW ID LPAREN RPAREN .)


state 190

    (61) factor -> NEW INT LSQUARE expr . RSQUARE
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    RSQUARE         shift and go to state 212
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 191

    (81) statement -> ID LSQUARE expr RSQUARE EQUALS . expr SEMICOLON
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 213
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 192

    (82) statement -> ID DOT ID EQUALS expr . SEMICOLON
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    SEMICOLON       shift and go to state 214
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 193

    (83) statement -> ID DOT ID LPAREN args . RPAREN SEMICOLON

    RPAREN          shift and go to state 215


state 194

    (84) statement -> ID LPAREN args RPAREN SEMICOLON .

    PUBLIC          reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    LBRACE          reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    IF              reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    WHILE           reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    SYSTEM          reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    ID              reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    RETURN          reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    PLUS_PLUS       reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    MINUS_MINUS     reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    THIS            reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    INT             reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    STRING          reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    VOID            reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    PRIVATE         reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    PROTECTED       reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    FOR             reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    RBRACE          reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)
    ELSE            reduce using rule 84 (statement -> ID LPAREN args RPAREN SEMICOLON .)


state 195

    (64) args -> expr COMMA args .

    RPAREN          reduce using rule 64 (args -> expr COMMA args .)


state 196

    (22) params -> type ID .
    (23) params -> type ID . COMMA params

    RPAREN          reduce using rule 22 (params -> type ID .)
    COMMA           shift and go to state 216


state 197

    (17) method_decl -> type ID LPAREN params RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 217


state 198

    (19) method_decl -> type ID LPAREN RPAREN LBRACE . body RBRACE
    (25) body -> . var_decl body
    (26) body -> . method_decl body
    (27) body -> . statement body
    (28) body -> . empty
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (17) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (20) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (21) method_decl -> . PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (94) empty -> .
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    PUBLIC          shift and go to state 44
    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 35
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    RBRACE          reduce using rule 94 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    FOR             shift and go to state 53

    type                           shift and go to state 42
    body                           shift and go to state 218
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    access_modifier                shift and go to state 43
    for_loop                       shift and go to state 52

state 199

    (18) method_decl -> access_modifier type ID LPAREN params . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 219


state 200

    (20) method_decl -> access_modifier STATIC type ID LPAREN . params RPAREN LBRACE body RBRACE
    (22) params -> . type ID
    (23) params -> . type ID COMMA params
    (24) params -> . empty
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (94) empty -> .

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18
    RPAREN          reduce using rule 94 (empty -> .)

    type                           shift and go to state 170
    params                         shift and go to state 220
    empty                          shift and go to state 173

state 201

    (21) method_decl -> PUBLIC STATIC VOID MAIN LPAREN . params RPAREN LBRACE body RBRACE
    (22) params -> . type ID
    (23) params -> . type ID COMMA params
    (24) params -> . empty
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (94) empty -> .

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18
    RPAREN          reduce using rule 94 (empty -> .)

    params                         shift and go to state 221
    type                           shift and go to state 170
    empty                          shift and go to state 173

state 202

    (76) statement -> IF LPAREN expr RPAREN statement . ELSE statement
    (77) statement -> IF LPAREN expr RPAREN statement .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 222
    PUBLIC          reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    LBRACE          reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    IF              reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    WHILE           reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    SYSTEM          reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    ID              reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    RETURN          reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    PLUS_PLUS       reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    MINUS_MINUS     reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    THIS            reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    INT             reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    BOOLEAN         reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    STRING          reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    VOID            reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    PRIVATE         reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    PROTECTED       reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    FOR             reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)
    RBRACE          reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .)

  ! ELSE            [ reduce using rule 77 (statement -> IF LPAREN expr RPAREN statement .) ]


state 203

    (80) statement -> ID . EQUALS expr SEMICOLON
    (81) statement -> ID . LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> ID . DOT ID EQUALS expr SEMICOLON
    (83) statement -> ID . DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> ID . LPAREN args RPAREN SEMICOLON
    (87) statement -> ID . PLUS_PLUS SEMICOLON
    (88) statement -> ID . MINUS_MINUS SEMICOLON

    EQUALS          shift and go to state 70
    LSQUARE         shift and go to state 71
    DOT             shift and go to state 72
    LPAREN          shift and go to state 73
    PLUS_PLUS       shift and go to state 74
    MINUS_MINUS     shift and go to state 75


state 204

    (78) statement -> WHILE LPAREN expr RPAREN statement .

    PUBLIC          reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    LBRACE          reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    IF              reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    WHILE           reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    SYSTEM          reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    ID              reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    RETURN          reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    PLUS_PLUS       reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    MINUS_MINUS     reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    THIS            reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    INT             reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    BOOLEAN         reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    STRING          reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    VOID            reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    PRIVATE         reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    PROTECTED       reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    FOR             reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    RBRACE          reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)
    ELSE            reduce using rule 78 (statement -> WHILE LPAREN expr RPAREN statement .)


state 205

    (79) statement -> SYSTEM DOT OUT DOT PRINTLN . LPAREN expr RPAREN SEMICOLON

    LPAREN          shift and go to state 223


state 206

    (91) statement -> THIS DOT ID EQUAL expr . SEMICOLON
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    SEMICOLON       shift and go to state 224
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 207

    (92) statement -> THIS DOT ID LPAREN args . RPAREN SEMICOLON

    RPAREN          shift and go to state 225


state 208

    (66) for_loop -> FOR LPAREN var_decl expr SEMICOLON . assign_expr RPAREN statement
    (68) for_loop -> FOR LPAREN var_decl expr SEMICOLON . increment_expr RPAREN statement
    (70) assign_expr -> . ID EQUALS expr
    (71) increment_expr -> . ID PLUS_PLUS
    (72) increment_expr -> . ID MINUS_MINUS
    (73) increment_expr -> . PLUS_PLUS ID
    (74) increment_expr -> . MINUS_MINUS ID

    ID              shift and go to state 228
    PLUS_PLUS       shift and go to state 229
    MINUS_MINUS     shift and go to state 230

    assign_expr                    shift and go to state 226
    increment_expr                 shift and go to state 227

state 209

    (67) for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON . assign_expr RPAREN statement
    (69) for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON . increment_expr RPAREN statement
    (70) assign_expr -> . ID EQUALS expr
    (71) increment_expr -> . ID PLUS_PLUS
    (72) increment_expr -> . ID MINUS_MINUS
    (73) increment_expr -> . PLUS_PLUS ID
    (74) increment_expr -> . MINUS_MINUS ID

    ID              shift and go to state 228
    PLUS_PLUS       shift and go to state 229
    MINUS_MINUS     shift and go to state 230

    assign_expr                    shift and go to state 231
    increment_expr                 shift and go to state 232

state 210

    (8) class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .

    CLASS           reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    IMPORT          reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    PUBLIC          reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    PRIVATE         reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    PROTECTED       reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    INT             reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    STRING          reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    ID              reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    VOID            reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    $end            reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)


state 211

    (58) factor -> ID DOT ID LPAREN args . RPAREN

    RPAREN          shift and go to state 233


state 212

    (61) factor -> NEW INT LSQUARE expr RSQUARE .

    TIMES           reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    DIVIDE          reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    SEMICOLON       reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    PLUS            reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    MINUS           reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    AND             reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    OR              reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    EQUALS          reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    NOT_EQUALS      reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    LESS_THAN       reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    LESS_THAN_OR_EQUAL reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    GREATER_THAN    reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    GREATER_THAN_OR_EQUAL reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    RPAREN          reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    RSQUARE         reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)
    COMMA           reduce using rule 61 (factor -> NEW INT LSQUARE expr RSQUARE .)


state 213

    (81) statement -> ID LSQUARE expr RSQUARE EQUALS expr . SEMICOLON
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    SEMICOLON       shift and go to state 234
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 214

    (82) statement -> ID DOT ID EQUALS expr SEMICOLON .

    PUBLIC          reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    LBRACE          reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    IF              reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    WHILE           reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    SYSTEM          reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    ID              reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    RETURN          reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    THIS            reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    INT             reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    BOOLEAN         reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    STRING          reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    VOID            reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    PRIVATE         reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    PROTECTED       reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    FOR             reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    RBRACE          reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)
    ELSE            reduce using rule 82 (statement -> ID DOT ID EQUALS expr SEMICOLON .)


state 215

    (83) statement -> ID DOT ID LPAREN args RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 235


state 216

    (23) params -> type ID COMMA . params
    (22) params -> . type ID
    (23) params -> . type ID COMMA params
    (24) params -> . empty
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (94) empty -> .

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18
    RPAREN          reduce using rule 94 (empty -> .)

    type                           shift and go to state 170
    params                         shift and go to state 236
    empty                          shift and go to state 173

state 217

    (17) method_decl -> type ID LPAREN params RPAREN LBRACE . body RBRACE
    (25) body -> . var_decl body
    (26) body -> . method_decl body
    (27) body -> . statement body
    (28) body -> . empty
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (17) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (20) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (21) method_decl -> . PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (94) empty -> .
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    PUBLIC          shift and go to state 44
    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 35
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    RBRACE          reduce using rule 94 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    FOR             shift and go to state 53

    type                           shift and go to state 42
    body                           shift and go to state 237
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    access_modifier                shift and go to state 43
    for_loop                       shift and go to state 52

state 218

    (19) method_decl -> type ID LPAREN RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 238


state 219

    (18) method_decl -> access_modifier type ID LPAREN params RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 239


state 220

    (20) method_decl -> access_modifier STATIC type ID LPAREN params . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 240


state 221

    (21) method_decl -> PUBLIC STATIC VOID MAIN LPAREN params . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 241


state 222

    (76) statement -> IF LPAREN expr RPAREN statement ELSE . statement
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 203
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    FOR             shift and go to state 53

    statement                      shift and go to state 242
    for_loop                       shift and go to state 52

state 223

    (79) statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN . expr RPAREN SEMICOLON
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 243
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 224

    (91) statement -> THIS DOT ID EQUAL expr SEMICOLON .

    PUBLIC          reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    LBRACE          reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    IF              reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    WHILE           reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    SYSTEM          reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    ID              reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    RETURN          reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    THIS            reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    INT             reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    BOOLEAN         reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    STRING          reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    VOID            reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    PRIVATE         reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    PROTECTED       reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    FOR             reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    RBRACE          reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)
    ELSE            reduce using rule 91 (statement -> THIS DOT ID EQUAL expr SEMICOLON .)


state 225

    (92) statement -> THIS DOT ID LPAREN args RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 244


state 226

    (66) for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr . RPAREN statement

    RPAREN          shift and go to state 245


state 227

    (68) for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr . RPAREN statement

    RPAREN          shift and go to state 246


state 228

    (70) assign_expr -> ID . EQUALS expr
    (71) increment_expr -> ID . PLUS_PLUS
    (72) increment_expr -> ID . MINUS_MINUS

    EQUALS          shift and go to state 247
    PLUS_PLUS       shift and go to state 248
    MINUS_MINUS     shift and go to state 249


state 229

    (73) increment_expr -> PLUS_PLUS . ID

    ID              shift and go to state 250


state 230

    (74) increment_expr -> MINUS_MINUS . ID

    ID              shift and go to state 251


state 231

    (67) for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr . RPAREN statement

    RPAREN          shift and go to state 252


state 232

    (69) for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr . RPAREN statement

    RPAREN          shift and go to state 253


state 233

    (58) factor -> ID DOT ID LPAREN args RPAREN .

    TIMES           reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    DIVIDE          reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    SEMICOLON       reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    PLUS            reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    MINUS           reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    AND             reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    OR              reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    EQUALS          reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    NOT_EQUALS      reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    LESS_THAN       reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    LESS_THAN_OR_EQUAL reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    GREATER_THAN    reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    GREATER_THAN_OR_EQUAL reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    RPAREN          reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    RSQUARE         reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)
    COMMA           reduce using rule 58 (factor -> ID DOT ID LPAREN args RPAREN .)


state 234

    (81) statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .

    PUBLIC          reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    LBRACE          reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    IF              reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    WHILE           reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    SYSTEM          reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    ID              reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    RETURN          reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    THIS            reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    INT             reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    BOOLEAN         reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    STRING          reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    VOID            reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    PRIVATE         reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    PROTECTED       reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    FOR             reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    RBRACE          reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    ELSE            reduce using rule 81 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)


state 235

    (83) statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .

    PUBLIC          reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    LBRACE          reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    IF              reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    WHILE           reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    SYSTEM          reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    ID              reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    RETURN          reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    PLUS_PLUS       reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    MINUS_MINUS     reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    THIS            reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    INT             reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    STRING          reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    VOID            reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    PRIVATE         reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    PROTECTED       reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    FOR             reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    RBRACE          reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)
    ELSE            reduce using rule 83 (statement -> ID DOT ID LPAREN args RPAREN SEMICOLON .)


state 236

    (23) params -> type ID COMMA params .

    RPAREN          reduce using rule 23 (params -> type ID COMMA params .)


state 237

    (17) method_decl -> type ID LPAREN params RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 254


state 238

    (19) method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .

    PUBLIC          reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    LBRACE          reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    SYSTEM          reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    PLUS_PLUS       reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    MINUS_MINUS     reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    THIS            reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    VOID            reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    PRIVATE         reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    PROTECTED       reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 19 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)


state 239

    (18) method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE . body RBRACE
    (25) body -> . var_decl body
    (26) body -> . method_decl body
    (27) body -> . statement body
    (28) body -> . empty
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (17) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (20) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (21) method_decl -> . PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (94) empty -> .
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    PUBLIC          shift and go to state 44
    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 35
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    RBRACE          reduce using rule 94 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    FOR             shift and go to state 53

    access_modifier                shift and go to state 43
    type                           shift and go to state 42
    body                           shift and go to state 255
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    for_loop                       shift and go to state 52

state 240

    (20) method_decl -> access_modifier STATIC type ID LPAREN params RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 256


state 241

    (21) method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 257


state 242

    (76) statement -> IF LPAREN expr RPAREN statement ELSE statement .

    PUBLIC          reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    LBRACE          reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    IF              reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    WHILE           reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    SYSTEM          reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    ID              reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    RETURN          reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    PLUS_PLUS       reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    MINUS_MINUS     reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    THIS            reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    INT             reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    BOOLEAN         reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    STRING          reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    VOID            reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    PRIVATE         reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    PROTECTED       reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    FOR             reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    RBRACE          reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    ELSE            reduce using rule 76 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)


state 243

    (79) statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr . RPAREN SEMICOLON
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    RPAREN          shift and go to state 258
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 244

    (92) statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .

    PUBLIC          reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    LBRACE          reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    IF              reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    WHILE           reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    SYSTEM          reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    ID              reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    RETURN          reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    PLUS_PLUS       reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    MINUS_MINUS     reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    THIS            reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    INT             reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    STRING          reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    VOID            reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    PRIVATE         reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    PROTECTED       reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    FOR             reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    RBRACE          reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)
    ELSE            reduce using rule 92 (statement -> THIS DOT ID LPAREN args RPAREN SEMICOLON .)


state 245

    (66) for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN . statement
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 203
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    FOR             shift and go to state 53

    statement                      shift and go to state 259
    for_loop                       shift and go to state 52

state 246

    (68) for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN . statement
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 203
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    FOR             shift and go to state 53

    statement                      shift and go to state 260
    for_loop                       shift and go to state 52

state 247

    (70) assign_expr -> ID EQUALS . expr
    (35) expr -> . expr PLUS term
    (36) expr -> . expr MINUS term
    (37) expr -> . expr AND term
    (38) expr -> . expr OR term
    (39) expr -> . expr EQUALS term
    (40) expr -> . expr NOT_EQUALS term
    (41) expr -> . expr LESS_THAN term
    (42) expr -> . expr LESS_THAN_OR_EQUAL term
    (43) expr -> . expr GREATER_THAN term
    (44) expr -> . expr GREATER_THAN_OR_EQUAL term
    (45) expr -> . term
    (46) term -> . term TIMES factor
    (47) term -> . term DIVIDE factor
    (48) term -> . factor
    (49) factor -> . MINUS factor
    (50) factor -> . NOT factor
    (51) factor -> . INT_LITERAL
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . STRING_LITERAL
    (55) factor -> . ID
    (56) factor -> . ID LSQUARE expr RSQUARE
    (57) factor -> . ID DOT ID
    (58) factor -> . ID DOT ID LPAREN args RPAREN
    (59) factor -> . ID LPAREN args RPAREN
    (60) factor -> . NEW ID LPAREN RPAREN
    (61) factor -> . NEW INT LSQUARE expr RSQUARE
    (62) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 60
    NOT             shift and go to state 62
    INT_LITERAL     shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 57
    NEW             shift and go to state 68
    LPAREN          shift and go to state 67

    expr                           shift and go to state 261
    term                           shift and go to state 59
    factor                         shift and go to state 61

state 248

    (71) increment_expr -> ID PLUS_PLUS .

    RPAREN          reduce using rule 71 (increment_expr -> ID PLUS_PLUS .)


state 249

    (72) increment_expr -> ID MINUS_MINUS .

    RPAREN          reduce using rule 72 (increment_expr -> ID MINUS_MINUS .)


state 250

    (73) increment_expr -> PLUS_PLUS ID .

    RPAREN          reduce using rule 73 (increment_expr -> PLUS_PLUS ID .)


state 251

    (74) increment_expr -> MINUS_MINUS ID .

    RPAREN          reduce using rule 74 (increment_expr -> MINUS_MINUS ID .)


state 252

    (67) for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN . statement
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 203
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    FOR             shift and go to state 53

    statement                      shift and go to state 262
    for_loop                       shift and go to state 52

state 253

    (69) for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN . statement
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 203
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    FOR             shift and go to state 53

    statement                      shift and go to state 263
    for_loop                       shift and go to state 52

state 254

    (17) method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .

    PUBLIC          reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    LBRACE          reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    SYSTEM          reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PLUS_PLUS       reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    MINUS_MINUS     reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    THIS            reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    VOID            reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PRIVATE         reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PROTECTED       reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 17 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)


state 255

    (18) method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 264


state 256

    (20) method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE . body RBRACE
    (25) body -> . var_decl body
    (26) body -> . method_decl body
    (27) body -> . statement body
    (28) body -> . empty
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (17) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (20) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (21) method_decl -> . PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (94) empty -> .
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    PUBLIC          shift and go to state 44
    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 35
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    RBRACE          reduce using rule 94 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    FOR             shift and go to state 53

    access_modifier                shift and go to state 43
    type                           shift and go to state 42
    body                           shift and go to state 265
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    for_loop                       shift and go to state 52

state 257

    (21) method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE . body RBRACE
    (25) body -> . var_decl body
    (26) body -> . method_decl body
    (27) body -> . statement body
    (28) body -> . empty
    (15) var_decl -> . type ID SEMICOLON
    (16) var_decl -> . type ID EQUAL expr SEMICOLON
    (17) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (20) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (21) method_decl -> . PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE
    (75) statement -> . LBRACE body RBRACE
    (76) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (77) statement -> . IF LPAREN expr RPAREN statement
    (78) statement -> . WHILE LPAREN expr RPAREN statement
    (79) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (80) statement -> . ID EQUALS expr SEMICOLON
    (81) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (82) statement -> . ID DOT ID EQUALS expr SEMICOLON
    (83) statement -> . ID DOT ID LPAREN args RPAREN SEMICOLON
    (84) statement -> . ID LPAREN args RPAREN SEMICOLON
    (85) statement -> . RETURN expr SEMICOLON
    (86) statement -> . RETURN SEMICOLON
    (87) statement -> . ID PLUS_PLUS SEMICOLON
    (88) statement -> . ID MINUS_MINUS SEMICOLON
    (89) statement -> . PLUS_PLUS ID SEMICOLON
    (90) statement -> . MINUS_MINUS ID SEMICOLON
    (91) statement -> . THIS DOT ID EQUAL expr SEMICOLON
    (92) statement -> . THIS DOT ID LPAREN args RPAREN SEMICOLON
    (93) statement -> . for_loop
    (94) empty -> .
    (29) type -> . INT
    (30) type -> . BOOLEAN
    (31) type -> . STRING
    (32) type -> . ID
    (33) type -> . VOID
    (34) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (66) for_loop -> . FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement
    (67) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement
    (68) for_loop -> . FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement
    (69) for_loop -> . FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement

    PUBLIC          shift and go to state 44
    LBRACE          shift and go to state 36
    IF              shift and go to state 45
    WHILE           shift and go to state 46
    SYSTEM          shift and go to state 47
    ID              shift and go to state 35
    RETURN          shift and go to state 48
    PLUS_PLUS       shift and go to state 49
    MINUS_MINUS     shift and go to state 50
    THIS            shift and go to state 51
    RBRACE          reduce using rule 94 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    FOR             shift and go to state 53

    body                           shift and go to state 266
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42
    access_modifier                shift and go to state 43
    for_loop                       shift and go to state 52

state 258

    (79) statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 267


state 259

    (66) for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .

    PUBLIC          reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    LBRACE          reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    IF              reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    WHILE           reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    SYSTEM          reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    ID              reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    RETURN          reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    PLUS_PLUS       reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    MINUS_MINUS     reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    THIS            reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    INT             reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    BOOLEAN         reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    STRING          reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    VOID            reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    PRIVATE         reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    PROTECTED       reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    FOR             reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    RBRACE          reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)
    ELSE            reduce using rule 66 (for_loop -> FOR LPAREN var_decl expr SEMICOLON assign_expr RPAREN statement .)


state 260

    (68) for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .

    PUBLIC          reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    LBRACE          reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    IF              reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    WHILE           reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    SYSTEM          reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    ID              reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    RETURN          reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    PLUS_PLUS       reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    MINUS_MINUS     reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    THIS            reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    INT             reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    BOOLEAN         reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    STRING          reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    VOID            reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    PRIVATE         reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    PROTECTED       reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    FOR             reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    RBRACE          reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)
    ELSE            reduce using rule 68 (for_loop -> FOR LPAREN var_decl expr SEMICOLON increment_expr RPAREN statement .)


state 261

    (70) assign_expr -> ID EQUALS expr .
    (35) expr -> expr . PLUS term
    (36) expr -> expr . MINUS term
    (37) expr -> expr . AND term
    (38) expr -> expr . OR term
    (39) expr -> expr . EQUALS term
    (40) expr -> expr . NOT_EQUALS term
    (41) expr -> expr . LESS_THAN term
    (42) expr -> expr . LESS_THAN_OR_EQUAL term
    (43) expr -> expr . GREATER_THAN term
    (44) expr -> expr . GREATER_THAN_OR_EQUAL term

    RPAREN          reduce using rule 70 (assign_expr -> ID EQUALS expr .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105
    EQUALS          shift and go to state 106
    NOT_EQUALS      shift and go to state 107
    LESS_THAN       shift and go to state 108
    LESS_THAN_OR_EQUAL shift and go to state 109
    GREATER_THAN    shift and go to state 110
    GREATER_THAN_OR_EQUAL shift and go to state 111


state 262

    (67) for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .

    PUBLIC          reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    LBRACE          reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    IF              reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    WHILE           reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    SYSTEM          reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    ID              reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    RETURN          reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    PLUS_PLUS       reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    MINUS_MINUS     reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    THIS            reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    INT             reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    BOOLEAN         reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    STRING          reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    VOID            reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    PRIVATE         reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    PROTECTED       reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    FOR             reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    RBRACE          reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)
    ELSE            reduce using rule 67 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON assign_expr RPAREN statement .)


state 263

    (69) for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .

    PUBLIC          reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    LBRACE          reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    IF              reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    WHILE           reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    SYSTEM          reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    ID              reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    RETURN          reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    PLUS_PLUS       reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    MINUS_MINUS     reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    THIS            reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    INT             reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    BOOLEAN         reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    STRING          reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    VOID            reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    PRIVATE         reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    PROTECTED       reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    FOR             reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    RBRACE          reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)
    ELSE            reduce using rule 69 (for_loop -> FOR LPAREN SEMICOLON expr SEMICOLON increment_expr RPAREN statement .)


state 264

    (18) method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .

    PUBLIC          reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    LBRACE          reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    SYSTEM          reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PLUS_PLUS       reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    MINUS_MINUS     reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    THIS            reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    VOID            reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PRIVATE         reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PROTECTED       reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 18 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)


state 265

    (20) method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 268


state 266

    (21) method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 269


state 267

    (79) statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .

    PUBLIC          reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    LBRACE          reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    IF              reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    WHILE           reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    SYSTEM          reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    ID              reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    RETURN          reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    PLUS_PLUS       reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    MINUS_MINUS     reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    THIS            reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    INT             reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    STRING          reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    VOID            reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    PRIVATE         reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    PROTECTED       reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    FOR             reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    RBRACE          reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    ELSE            reduce using rule 79 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)


state 268

    (20) method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .

    PUBLIC          reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    LBRACE          reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    SYSTEM          reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PLUS_PLUS       reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    MINUS_MINUS     reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    THIS            reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    VOID            reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PRIVATE         reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PROTECTED       reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 20 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)


state 269

    (21) method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .

    PUBLIC          reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    LBRACE          reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    SYSTEM          reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    PLUS_PLUS       reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    MINUS_MINUS     reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    THIS            reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    VOID            reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    PRIVATE         reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    PROTECTED       reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 21 (method_decl -> PUBLIC STATIC VOID MAIN LPAREN params RPAREN LBRACE body RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LSQUARE in state 35 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 44 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 129 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 202 resolved as shift
