Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    DOUBLE_QUOTE
    FALSE
    FOR
    GREATER_THAN
    GREATER_THAN_OR_EQUAL
    LESS_THAN
    LESS_THAN_OR_EQUAL
    MAIN
    NOT_EQUALS
    OR
    QUOTE
    RETURN
    THIS
    TRUE

Grammar

Rule 0     S' -> program
Rule 1     program -> body_program
Rule 2     body_program -> class_decl body_program
Rule 3     body_program -> import_decl body_program
Rule 4     body_program -> var_decl body_program
Rule 5     body_program -> empty
Rule 6     class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE
Rule 7     class_decl -> CLASS ID LBRACE body RBRACE
Rule 8     class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE
Rule 9     class_decl -> access_modifier CLASS ID LBRACE body RBRACE
Rule 10    access_modifier -> PUBLIC
Rule 11    access_modifier -> PRIVATE
Rule 12    access_modifier -> PROTECTED
Rule 13    import_decl -> IMPORT ID DOT ID SEMICOLON
Rule 14    var_decl -> type ID SEMICOLON
Rule 15    var_decl -> type ID EQUAL expr SEMICOLON
Rule 16    method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE
Rule 17    method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
Rule 18    method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE
Rule 19    method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
Rule 20    params -> type ID
Rule 21    params -> type ID COMMA params
Rule 22    params -> empty
Rule 23    body -> var_decl body
Rule 24    body -> method_decl body
Rule 25    body -> statement body
Rule 26    body -> empty
Rule 27    type -> INT
Rule 28    type -> BOOLEAN
Rule 29    type -> STRING
Rule 30    type -> ID
Rule 31    type -> VOID
Rule 32    type -> type LSQUARE RSQUARE
Rule 33    expr -> expr PLUS term
Rule 34    expr -> expr MINUS term
Rule 35    expr -> term
Rule 36    term -> term TIMES factor
Rule 37    term -> term DIVIDE factor
Rule 38    term -> factor
Rule 39    factor -> MINUS factor
Rule 40    factor -> NOT factor
Rule 41    factor -> INT_LITERAL
Rule 42    factor -> BOOLEAN_LITERAL
Rule 43    factor -> STRING_LITERAL
Rule 44    factor -> ID
Rule 45    factor -> ID LSQUARE expr RSQUARE
Rule 46    factor -> ID DOT ID
Rule 47    factor -> ID DOT ID LPAREN args RPAREN
Rule 48    factor -> ID LPAREN args RPAREN
Rule 49    factor -> NEW ID LPAREN RPAREN
Rule 50    factor -> NEW INT LSQUARE expr RSQUARE
Rule 51    factor -> LPAREN expr RPAREN
Rule 52    args -> expr
Rule 53    args -> expr COMMA args
Rule 54    args -> empty
Rule 55    statement -> LBRACE body RBRACE
Rule 56    statement -> IF LPAREN expr RPAREN statement ELSE statement
Rule 57    statement -> IF LPAREN expr RPAREN statement
Rule 58    statement -> WHILE LPAREN expr RPAREN statement
Rule 59    statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
Rule 60    statement -> ID EQUALS expr SEMICOLON
Rule 61    statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
Rule 62    empty -> <empty>

Terminals, with rules where they appear

AND                  : 
BOOLEAN              : 28
BOOLEAN_LITERAL      : 42
CLASS                : 6 7 8 9
COMMA                : 21 53
DIVIDE               : 37
DOT                  : 13 46 47 59 59
DOUBLE_QUOTE         : 
ELSE                 : 56
EQUAL                : 15
EQUALS               : 60 61
EXTENDS              : 6 8
FALSE                : 
FOR                  : 
GREATER_THAN         : 
GREATER_THAN_OR_EQUAL : 
ID                   : 6 6 7 8 8 9 13 13 14 15 16 17 18 19 20 21 30 44 45 46 46 47 47 48 49 60 61
IF                   : 56 57
IMPORT               : 13
INT                  : 27 50
INT_LITERAL          : 41
LBRACE               : 6 7 8 9 16 17 18 19 55
LESS_THAN            : 
LESS_THAN_OR_EQUAL   : 
LPAREN               : 16 17 18 19 47 48 49 51 56 57 58 59
LSQUARE              : 32 45 50 61
MAIN                 : 
MINUS                : 34 39
NEW                  : 49 50
NOT                  : 40
NOT_EQUALS           : 
OR                   : 
OUT                  : 59
PLUS                 : 33
PRINTLN              : 59
PRIVATE              : 11
PROTECTED            : 12
PUBLIC               : 10
QUOTE                : 
RBRACE               : 6 7 8 9 16 17 18 19 55
RETURN               : 
RPAREN               : 16 17 18 19 47 48 49 51 56 57 58 59
RSQUARE              : 32 45 50 61
SEMICOLON            : 13 14 15 59 60 61
STATIC               : 19
STRING               : 29
STRING_LITERAL       : 43
SYSTEM               : 59
THIS                 : 
TIMES                : 36
TRUE                 : 
VOID                 : 31
WHILE                : 58
error                : 

Nonterminals, with rules where they appear

access_modifier      : 8 9 17 19
args                 : 47 48 53
body                 : 6 7 8 9 16 17 18 19 23 24 25 55
body_program         : 1 2 3 4
class_decl           : 2
empty                : 5 22 26 54
expr                 : 15 33 34 45 50 51 52 53 56 57 58 59 60 61 61
factor               : 36 37 38 39 40
import_decl          : 3
method_decl          : 24
params               : 16 17 19 21
program              : 0
statement            : 25 56 56 57 58
term                 : 33 34 35 36 37
type                 : 14 15 16 17 18 19 20 21 32
var_decl             : 4 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . body_program
    (2) body_program -> . class_decl body_program
    (3) body_program -> . import_decl body_program
    (4) body_program -> . var_decl body_program
    (5) body_program -> . empty
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> . CLASS ID LBRACE body RBRACE
    (8) class_decl -> . access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE
    (9) class_decl -> . access_modifier CLASS ID LBRACE body RBRACE
    (13) import_decl -> . IMPORT ID DOT ID SEMICOLON
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (62) empty -> .
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE

    CLASS           shift and go to state 7
    IMPORT          shift and go to state 10
    $end            reduce using rule 62 (empty -> .)
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

    program                        shift and go to state 1
    body_program                   shift and go to state 2
    class_decl                     shift and go to state 3
    import_decl                    shift and go to state 4
    var_decl                       shift and go to state 5
    empty                          shift and go to state 6
    access_modifier                shift and go to state 9
    type                           shift and go to state 11

state 1

    (0) S' -> program .



state 2

    (1) program -> body_program .

    $end            reduce using rule 1 (program -> body_program .)


state 3

    (2) body_program -> class_decl . body_program
    (2) body_program -> . class_decl body_program
    (3) body_program -> . import_decl body_program
    (4) body_program -> . var_decl body_program
    (5) body_program -> . empty
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> . CLASS ID LBRACE body RBRACE
    (8) class_decl -> . access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE
    (9) class_decl -> . access_modifier CLASS ID LBRACE body RBRACE
    (13) import_decl -> . IMPORT ID DOT ID SEMICOLON
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (62) empty -> .
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE

    CLASS           shift and go to state 7
    IMPORT          shift and go to state 10
    $end            reduce using rule 62 (empty -> .)
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

    class_decl                     shift and go to state 3
    body_program                   shift and go to state 19
    import_decl                    shift and go to state 4
    var_decl                       shift and go to state 5
    empty                          shift and go to state 6
    access_modifier                shift and go to state 9
    type                           shift and go to state 11

state 4

    (3) body_program -> import_decl . body_program
    (2) body_program -> . class_decl body_program
    (3) body_program -> . import_decl body_program
    (4) body_program -> . var_decl body_program
    (5) body_program -> . empty
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> . CLASS ID LBRACE body RBRACE
    (8) class_decl -> . access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE
    (9) class_decl -> . access_modifier CLASS ID LBRACE body RBRACE
    (13) import_decl -> . IMPORT ID DOT ID SEMICOLON
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (62) empty -> .
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE

    CLASS           shift and go to state 7
    IMPORT          shift and go to state 10
    $end            reduce using rule 62 (empty -> .)
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

    import_decl                    shift and go to state 4
    body_program                   shift and go to state 20
    class_decl                     shift and go to state 3
    var_decl                       shift and go to state 5
    empty                          shift and go to state 6
    access_modifier                shift and go to state 9
    type                           shift and go to state 11

state 5

    (4) body_program -> var_decl . body_program
    (2) body_program -> . class_decl body_program
    (3) body_program -> . import_decl body_program
    (4) body_program -> . var_decl body_program
    (5) body_program -> . empty
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> . CLASS ID LBRACE body RBRACE
    (8) class_decl -> . access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE
    (9) class_decl -> . access_modifier CLASS ID LBRACE body RBRACE
    (13) import_decl -> . IMPORT ID DOT ID SEMICOLON
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (62) empty -> .
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE

    CLASS           shift and go to state 7
    IMPORT          shift and go to state 10
    $end            reduce using rule 62 (empty -> .)
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

    var_decl                       shift and go to state 5
    body_program                   shift and go to state 21
    class_decl                     shift and go to state 3
    import_decl                    shift and go to state 4
    empty                          shift and go to state 6
    access_modifier                shift and go to state 9
    type                           shift and go to state 11

state 6

    (5) body_program -> empty .

    $end            reduce using rule 5 (body_program -> empty .)


state 7

    (6) class_decl -> CLASS . ID EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> CLASS . ID LBRACE body RBRACE

    ID              shift and go to state 22


state 8

    (30) type -> ID .

    ID              reduce using rule 30 (type -> ID .)
    LSQUARE         reduce using rule 30 (type -> ID .)


state 9

    (8) class_decl -> access_modifier . CLASS ID EXTENDS ID LBRACE body RBRACE
    (9) class_decl -> access_modifier . CLASS ID LBRACE body RBRACE

    CLASS           shift and go to state 23


state 10

    (13) import_decl -> IMPORT . ID DOT ID SEMICOLON

    ID              shift and go to state 24


state 11

    (14) var_decl -> type . ID SEMICOLON
    (15) var_decl -> type . ID EQUAL expr SEMICOLON
    (32) type -> type . LSQUARE RSQUARE

    ID              shift and go to state 25
    LSQUARE         shift and go to state 26


state 12

    (10) access_modifier -> PUBLIC .

    CLASS           reduce using rule 10 (access_modifier -> PUBLIC .)
    STATIC          reduce using rule 10 (access_modifier -> PUBLIC .)
    INT             reduce using rule 10 (access_modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 10 (access_modifier -> PUBLIC .)
    STRING          reduce using rule 10 (access_modifier -> PUBLIC .)
    ID              reduce using rule 10 (access_modifier -> PUBLIC .)
    VOID            reduce using rule 10 (access_modifier -> PUBLIC .)


state 13

    (11) access_modifier -> PRIVATE .

    CLASS           reduce using rule 11 (access_modifier -> PRIVATE .)
    STATIC          reduce using rule 11 (access_modifier -> PRIVATE .)
    INT             reduce using rule 11 (access_modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 11 (access_modifier -> PRIVATE .)
    STRING          reduce using rule 11 (access_modifier -> PRIVATE .)
    ID              reduce using rule 11 (access_modifier -> PRIVATE .)
    VOID            reduce using rule 11 (access_modifier -> PRIVATE .)


state 14

    (12) access_modifier -> PROTECTED .

    CLASS           reduce using rule 12 (access_modifier -> PROTECTED .)
    STATIC          reduce using rule 12 (access_modifier -> PROTECTED .)
    INT             reduce using rule 12 (access_modifier -> PROTECTED .)
    BOOLEAN         reduce using rule 12 (access_modifier -> PROTECTED .)
    STRING          reduce using rule 12 (access_modifier -> PROTECTED .)
    ID              reduce using rule 12 (access_modifier -> PROTECTED .)
    VOID            reduce using rule 12 (access_modifier -> PROTECTED .)


state 15

    (27) type -> INT .

    ID              reduce using rule 27 (type -> INT .)
    LSQUARE         reduce using rule 27 (type -> INT .)


state 16

    (28) type -> BOOLEAN .

    ID              reduce using rule 28 (type -> BOOLEAN .)
    LSQUARE         reduce using rule 28 (type -> BOOLEAN .)


state 17

    (29) type -> STRING .

    ID              reduce using rule 29 (type -> STRING .)
    LSQUARE         reduce using rule 29 (type -> STRING .)


state 18

    (31) type -> VOID .

    ID              reduce using rule 31 (type -> VOID .)
    LSQUARE         reduce using rule 31 (type -> VOID .)


state 19

    (2) body_program -> class_decl body_program .

    $end            reduce using rule 2 (body_program -> class_decl body_program .)


state 20

    (3) body_program -> import_decl body_program .

    $end            reduce using rule 3 (body_program -> import_decl body_program .)


state 21

    (4) body_program -> var_decl body_program .

    $end            reduce using rule 4 (body_program -> var_decl body_program .)


state 22

    (6) class_decl -> CLASS ID . EXTENDS ID LBRACE body RBRACE
    (7) class_decl -> CLASS ID . LBRACE body RBRACE

    EXTENDS         shift and go to state 27
    LBRACE          shift and go to state 28


state 23

    (8) class_decl -> access_modifier CLASS . ID EXTENDS ID LBRACE body RBRACE
    (9) class_decl -> access_modifier CLASS . ID LBRACE body RBRACE

    ID              shift and go to state 29


state 24

    (13) import_decl -> IMPORT ID . DOT ID SEMICOLON

    DOT             shift and go to state 30


state 25

    (14) var_decl -> type ID . SEMICOLON
    (15) var_decl -> type ID . EQUAL expr SEMICOLON

    SEMICOLON       shift and go to state 31
    EQUAL           shift and go to state 32


state 26

    (32) type -> type LSQUARE . RSQUARE

    RSQUARE         shift and go to state 33


state 27

    (6) class_decl -> CLASS ID EXTENDS . ID LBRACE body RBRACE

    ID              shift and go to state 34


state 28

    (7) class_decl -> CLASS ID LBRACE . body RBRACE
    (23) body -> . var_decl body
    (24) body -> . method_decl body
    (25) body -> . statement body
    (26) body -> . empty
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (16) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (17) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (19) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (62) empty -> .
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 35
    RBRACE          reduce using rule 62 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14

    body                           shift and go to state 37
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42
    access_modifier                shift and go to state 43

state 29

    (8) class_decl -> access_modifier CLASS ID . EXTENDS ID LBRACE body RBRACE
    (9) class_decl -> access_modifier CLASS ID . LBRACE body RBRACE

    EXTENDS         shift and go to state 47
    LBRACE          shift and go to state 48


state 30

    (13) import_decl -> IMPORT ID DOT . ID SEMICOLON

    ID              shift and go to state 49


state 31

    (14) var_decl -> type ID SEMICOLON .

    CLASS           reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    IMPORT          reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    PUBLIC          reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    PRIVATE         reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    PROTECTED       reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    INT             reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    BOOLEAN         reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    STRING          reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    ID              reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    VOID            reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    $end            reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    LBRACE          reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    IF              reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    WHILE           reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    SYSTEM          reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    RBRACE          reduce using rule 14 (var_decl -> type ID SEMICOLON .)


state 32

    (15) var_decl -> type ID EQUAL . expr SEMICOLON
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . term
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    expr                           shift and go to state 51
    term                           shift and go to state 52
    factor                         shift and go to state 54

state 33

    (32) type -> type LSQUARE RSQUARE .

    ID              reduce using rule 32 (type -> type LSQUARE RSQUARE .)
    LSQUARE         reduce using rule 32 (type -> type LSQUARE RSQUARE .)


state 34

    (6) class_decl -> CLASS ID EXTENDS ID . LBRACE body RBRACE

    LBRACE          shift and go to state 61


state 35

    (60) statement -> ID . EQUALS expr SEMICOLON
    (61) statement -> ID . LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (30) type -> ID .

  ! shift/reduce conflict for LSQUARE resolved as shift
    EQUALS          shift and go to state 62
    LSQUARE         shift and go to state 63
    ID              reduce using rule 30 (type -> ID .)

  ! LSQUARE         [ reduce using rule 30 (type -> ID .) ]


state 36

    (55) statement -> LBRACE . body RBRACE
    (23) body -> . var_decl body
    (24) body -> . method_decl body
    (25) body -> . statement body
    (26) body -> . empty
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (16) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (17) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (19) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (62) empty -> .
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 35
    RBRACE          reduce using rule 62 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14

    body                           shift and go to state 64
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42
    access_modifier                shift and go to state 43

state 37

    (7) class_decl -> CLASS ID LBRACE body . RBRACE

    RBRACE          shift and go to state 65


state 38

    (23) body -> var_decl . body
    (23) body -> . var_decl body
    (24) body -> . method_decl body
    (25) body -> . statement body
    (26) body -> . empty
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (16) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (17) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (19) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (62) empty -> .
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 35
    RBRACE          reduce using rule 62 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14

    var_decl                       shift and go to state 38
    body                           shift and go to state 66
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42
    access_modifier                shift and go to state 43

state 39

    (24) body -> method_decl . body
    (23) body -> . var_decl body
    (24) body -> . method_decl body
    (25) body -> . statement body
    (26) body -> . empty
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (16) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (17) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (19) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (62) empty -> .
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 35
    RBRACE          reduce using rule 62 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14

    method_decl                    shift and go to state 39
    body                           shift and go to state 67
    var_decl                       shift and go to state 38
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42
    access_modifier                shift and go to state 43

state 40

    (25) body -> statement . body
    (23) body -> . var_decl body
    (24) body -> . method_decl body
    (25) body -> . statement body
    (26) body -> . empty
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (16) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (17) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (19) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (62) empty -> .
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 35
    RBRACE          reduce using rule 62 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14

    statement                      shift and go to state 40
    body                           shift and go to state 68
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    empty                          shift and go to state 41
    type                           shift and go to state 42
    access_modifier                shift and go to state 43

state 41

    (26) body -> empty .

    RBRACE          reduce using rule 26 (body -> empty .)


state 42

    (14) var_decl -> type . ID SEMICOLON
    (15) var_decl -> type . ID EQUAL expr SEMICOLON
    (16) method_decl -> type . ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> type . ID LPAREN RPAREN LBRACE body RBRACE
    (32) type -> type . LSQUARE RSQUARE

    ID              shift and go to state 69
    LSQUARE         shift and go to state 26


state 43

    (17) method_decl -> access_modifier . type ID LPAREN params RPAREN LBRACE body RBRACE
    (19) method_decl -> access_modifier . STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE

    STATIC          shift and go to state 71
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

    type                           shift and go to state 70

state 44

    (56) statement -> IF . LPAREN expr RPAREN statement ELSE statement
    (57) statement -> IF . LPAREN expr RPAREN statement

    LPAREN          shift and go to state 72


state 45

    (58) statement -> WHILE . LPAREN expr RPAREN statement

    LPAREN          shift and go to state 73


state 46

    (59) statement -> SYSTEM . DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON

    DOT             shift and go to state 74


state 47

    (8) class_decl -> access_modifier CLASS ID EXTENDS . ID LBRACE body RBRACE

    ID              shift and go to state 75


state 48

    (9) class_decl -> access_modifier CLASS ID LBRACE . body RBRACE
    (23) body -> . var_decl body
    (24) body -> . method_decl body
    (25) body -> . statement body
    (26) body -> . empty
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (16) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (17) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (19) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (62) empty -> .
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 35
    RBRACE          reduce using rule 62 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14

    access_modifier                shift and go to state 43
    body                           shift and go to state 76
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42

state 49

    (13) import_decl -> IMPORT ID DOT ID . SEMICOLON

    SEMICOLON       shift and go to state 77


state 50

    (44) factor -> ID .
    (45) factor -> ID . LSQUARE expr RSQUARE
    (46) factor -> ID . DOT ID
    (47) factor -> ID . DOT ID LPAREN args RPAREN
    (48) factor -> ID . LPAREN args RPAREN

    TIMES           reduce using rule 44 (factor -> ID .)
    DIVIDE          reduce using rule 44 (factor -> ID .)
    SEMICOLON       reduce using rule 44 (factor -> ID .)
    PLUS            reduce using rule 44 (factor -> ID .)
    MINUS           reduce using rule 44 (factor -> ID .)
    RPAREN          reduce using rule 44 (factor -> ID .)
    RSQUARE         reduce using rule 44 (factor -> ID .)
    COMMA           reduce using rule 44 (factor -> ID .)
    LSQUARE         shift and go to state 78
    DOT             shift and go to state 79
    LPAREN          shift and go to state 80


state 51

    (15) var_decl -> type ID EQUAL expr . SEMICOLON
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 52

    (35) expr -> term .
    (36) term -> term . TIMES factor
    (37) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 35 (expr -> term .)
    PLUS            reduce using rule 35 (expr -> term .)
    MINUS           reduce using rule 35 (expr -> term .)
    RPAREN          reduce using rule 35 (expr -> term .)
    RSQUARE         reduce using rule 35 (expr -> term .)
    COMMA           reduce using rule 35 (expr -> term .)
    TIMES           shift and go to state 84
    DIVIDE          shift and go to state 85


state 53

    (39) factor -> MINUS . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    factor                         shift and go to state 86

state 54

    (38) term -> factor .

    TIMES           reduce using rule 38 (term -> factor .)
    DIVIDE          reduce using rule 38 (term -> factor .)
    SEMICOLON       reduce using rule 38 (term -> factor .)
    PLUS            reduce using rule 38 (term -> factor .)
    MINUS           reduce using rule 38 (term -> factor .)
    RPAREN          reduce using rule 38 (term -> factor .)
    RSQUARE         reduce using rule 38 (term -> factor .)
    COMMA           reduce using rule 38 (term -> factor .)


state 55

    (40) factor -> NOT . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    factor                         shift and go to state 87

state 56

    (41) factor -> INT_LITERAL .

    TIMES           reduce using rule 41 (factor -> INT_LITERAL .)
    DIVIDE          reduce using rule 41 (factor -> INT_LITERAL .)
    SEMICOLON       reduce using rule 41 (factor -> INT_LITERAL .)
    PLUS            reduce using rule 41 (factor -> INT_LITERAL .)
    MINUS           reduce using rule 41 (factor -> INT_LITERAL .)
    RPAREN          reduce using rule 41 (factor -> INT_LITERAL .)
    RSQUARE         reduce using rule 41 (factor -> INT_LITERAL .)
    COMMA           reduce using rule 41 (factor -> INT_LITERAL .)


state 57

    (42) factor -> BOOLEAN_LITERAL .

    TIMES           reduce using rule 42 (factor -> BOOLEAN_LITERAL .)
    DIVIDE          reduce using rule 42 (factor -> BOOLEAN_LITERAL .)
    SEMICOLON       reduce using rule 42 (factor -> BOOLEAN_LITERAL .)
    PLUS            reduce using rule 42 (factor -> BOOLEAN_LITERAL .)
    MINUS           reduce using rule 42 (factor -> BOOLEAN_LITERAL .)
    RPAREN          reduce using rule 42 (factor -> BOOLEAN_LITERAL .)
    RSQUARE         reduce using rule 42 (factor -> BOOLEAN_LITERAL .)
    COMMA           reduce using rule 42 (factor -> BOOLEAN_LITERAL .)


state 58

    (43) factor -> STRING_LITERAL .

    TIMES           reduce using rule 43 (factor -> STRING_LITERAL .)
    DIVIDE          reduce using rule 43 (factor -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 43 (factor -> STRING_LITERAL .)
    PLUS            reduce using rule 43 (factor -> STRING_LITERAL .)
    MINUS           reduce using rule 43 (factor -> STRING_LITERAL .)
    RPAREN          reduce using rule 43 (factor -> STRING_LITERAL .)
    RSQUARE         reduce using rule 43 (factor -> STRING_LITERAL .)
    COMMA           reduce using rule 43 (factor -> STRING_LITERAL .)


state 59

    (51) factor -> LPAREN . expr RPAREN
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . term
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    expr                           shift and go to state 88
    term                           shift and go to state 52
    factor                         shift and go to state 54

state 60

    (49) factor -> NEW . ID LPAREN RPAREN
    (50) factor -> NEW . INT LSQUARE expr RSQUARE

    ID              shift and go to state 89
    INT             shift and go to state 90


state 61

    (6) class_decl -> CLASS ID EXTENDS ID LBRACE . body RBRACE
    (23) body -> . var_decl body
    (24) body -> . method_decl body
    (25) body -> . statement body
    (26) body -> . empty
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (16) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (17) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (19) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (62) empty -> .
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 35
    RBRACE          reduce using rule 62 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14

    body                           shift and go to state 91
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42
    access_modifier                shift and go to state 43

state 62

    (60) statement -> ID EQUALS . expr SEMICOLON
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . term
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    expr                           shift and go to state 92
    term                           shift and go to state 52
    factor                         shift and go to state 54

state 63

    (61) statement -> ID LSQUARE . expr RSQUARE EQUALS expr SEMICOLON
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . term
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    expr                           shift and go to state 93
    term                           shift and go to state 52
    factor                         shift and go to state 54

state 64

    (55) statement -> LBRACE body . RBRACE

    RBRACE          shift and go to state 94


state 65

    (7) class_decl -> CLASS ID LBRACE body RBRACE .

    CLASS           reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    IMPORT          reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    PUBLIC          reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    PRIVATE         reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    PROTECTED       reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    INT             reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    STRING          reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    ID              reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    VOID            reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)
    $end            reduce using rule 7 (class_decl -> CLASS ID LBRACE body RBRACE .)


state 66

    (23) body -> var_decl body .

    RBRACE          reduce using rule 23 (body -> var_decl body .)


state 67

    (24) body -> method_decl body .

    RBRACE          reduce using rule 24 (body -> method_decl body .)


state 68

    (25) body -> statement body .

    RBRACE          reduce using rule 25 (body -> statement body .)


state 69

    (14) var_decl -> type ID . SEMICOLON
    (15) var_decl -> type ID . EQUAL expr SEMICOLON
    (16) method_decl -> type ID . LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> type ID . LPAREN RPAREN LBRACE body RBRACE

    SEMICOLON       shift and go to state 31
    EQUAL           shift and go to state 32
    LPAREN          shift and go to state 95


state 70

    (17) method_decl -> access_modifier type . ID LPAREN params RPAREN LBRACE body RBRACE
    (32) type -> type . LSQUARE RSQUARE

    ID              shift and go to state 96
    LSQUARE         shift and go to state 26


state 71

    (19) method_decl -> access_modifier STATIC . type ID LPAREN params RPAREN LBRACE body RBRACE
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

    type                           shift and go to state 97

state 72

    (56) statement -> IF LPAREN . expr RPAREN statement ELSE statement
    (57) statement -> IF LPAREN . expr RPAREN statement
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . term
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    expr                           shift and go to state 98
    term                           shift and go to state 52
    factor                         shift and go to state 54

state 73

    (58) statement -> WHILE LPAREN . expr RPAREN statement
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . term
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    expr                           shift and go to state 99
    term                           shift and go to state 52
    factor                         shift and go to state 54

state 74

    (59) statement -> SYSTEM DOT . OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON

    OUT             shift and go to state 100


state 75

    (8) class_decl -> access_modifier CLASS ID EXTENDS ID . LBRACE body RBRACE

    LBRACE          shift and go to state 101


state 76

    (9) class_decl -> access_modifier CLASS ID LBRACE body . RBRACE

    RBRACE          shift and go to state 102


state 77

    (13) import_decl -> IMPORT ID DOT ID SEMICOLON .

    CLASS           reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    IMPORT          reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    PUBLIC          reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    PRIVATE         reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    PROTECTED       reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    INT             reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    BOOLEAN         reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    STRING          reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    ID              reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    VOID            reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)
    $end            reduce using rule 13 (import_decl -> IMPORT ID DOT ID SEMICOLON .)


state 78

    (45) factor -> ID LSQUARE . expr RSQUARE
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . term
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    expr                           shift and go to state 103
    term                           shift and go to state 52
    factor                         shift and go to state 54

state 79

    (46) factor -> ID DOT . ID
    (47) factor -> ID DOT . ID LPAREN args RPAREN

    ID              shift and go to state 104


state 80

    (48) factor -> ID LPAREN . args RPAREN
    (52) args -> . expr
    (53) args -> . expr COMMA args
    (54) args -> . empty
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . term
    (62) empty -> .
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    RPAREN          reduce using rule 62 (empty -> .)
    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    args                           shift and go to state 105
    expr                           shift and go to state 106
    empty                          shift and go to state 107
    term                           shift and go to state 52
    factor                         shift and go to state 54

state 81

    (15) var_decl -> type ID EQUAL expr SEMICOLON .

    CLASS           reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    IMPORT          reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    PUBLIC          reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    PRIVATE         reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    PROTECTED       reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    INT             reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    BOOLEAN         reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    STRING          reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    ID              reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    VOID            reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    $end            reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    LBRACE          reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    IF              reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    WHILE           reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    SYSTEM          reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)
    RBRACE          reduce using rule 15 (var_decl -> type ID EQUAL expr SEMICOLON .)


state 82

    (33) expr -> expr PLUS . term
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    term                           shift and go to state 108
    factor                         shift and go to state 54

state 83

    (34) expr -> expr MINUS . term
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    term                           shift and go to state 109
    factor                         shift and go to state 54

state 84

    (36) term -> term TIMES . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    factor                         shift and go to state 110

state 85

    (37) term -> term DIVIDE . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    factor                         shift and go to state 111

state 86

    (39) factor -> MINUS factor .

    TIMES           reduce using rule 39 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 39 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 39 (factor -> MINUS factor .)
    PLUS            reduce using rule 39 (factor -> MINUS factor .)
    MINUS           reduce using rule 39 (factor -> MINUS factor .)
    RPAREN          reduce using rule 39 (factor -> MINUS factor .)
    RSQUARE         reduce using rule 39 (factor -> MINUS factor .)
    COMMA           reduce using rule 39 (factor -> MINUS factor .)


state 87

    (40) factor -> NOT factor .

    TIMES           reduce using rule 40 (factor -> NOT factor .)
    DIVIDE          reduce using rule 40 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 40 (factor -> NOT factor .)
    PLUS            reduce using rule 40 (factor -> NOT factor .)
    MINUS           reduce using rule 40 (factor -> NOT factor .)
    RPAREN          reduce using rule 40 (factor -> NOT factor .)
    RSQUARE         reduce using rule 40 (factor -> NOT factor .)
    COMMA           reduce using rule 40 (factor -> NOT factor .)


state 88

    (51) factor -> LPAREN expr . RPAREN
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term

    RPAREN          shift and go to state 112
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 89

    (49) factor -> NEW ID . LPAREN RPAREN

    LPAREN          shift and go to state 113


state 90

    (50) factor -> NEW INT . LSQUARE expr RSQUARE

    LSQUARE         shift and go to state 114


state 91

    (6) class_decl -> CLASS ID EXTENDS ID LBRACE body . RBRACE

    RBRACE          shift and go to state 115


state 92

    (60) statement -> ID EQUALS expr . SEMICOLON
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 116
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 93

    (61) statement -> ID LSQUARE expr . RSQUARE EQUALS expr SEMICOLON
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term

    RSQUARE         shift and go to state 117
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 94

    (55) statement -> LBRACE body RBRACE .

    LBRACE          reduce using rule 55 (statement -> LBRACE body RBRACE .)
    IF              reduce using rule 55 (statement -> LBRACE body RBRACE .)
    WHILE           reduce using rule 55 (statement -> LBRACE body RBRACE .)
    SYSTEM          reduce using rule 55 (statement -> LBRACE body RBRACE .)
    ID              reduce using rule 55 (statement -> LBRACE body RBRACE .)
    INT             reduce using rule 55 (statement -> LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 55 (statement -> LBRACE body RBRACE .)
    STRING          reduce using rule 55 (statement -> LBRACE body RBRACE .)
    VOID            reduce using rule 55 (statement -> LBRACE body RBRACE .)
    PUBLIC          reduce using rule 55 (statement -> LBRACE body RBRACE .)
    PRIVATE         reduce using rule 55 (statement -> LBRACE body RBRACE .)
    PROTECTED       reduce using rule 55 (statement -> LBRACE body RBRACE .)
    RBRACE          reduce using rule 55 (statement -> LBRACE body RBRACE .)
    ELSE            reduce using rule 55 (statement -> LBRACE body RBRACE .)


state 95

    (16) method_decl -> type ID LPAREN . params RPAREN LBRACE body RBRACE
    (18) method_decl -> type ID LPAREN . RPAREN LBRACE body RBRACE
    (20) params -> . type ID
    (21) params -> . type ID COMMA params
    (22) params -> . empty
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (62) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 120
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18

  ! RPAREN          [ reduce using rule 62 (empty -> .) ]

    type                           shift and go to state 118
    params                         shift and go to state 119
    empty                          shift and go to state 121

state 96

    (17) method_decl -> access_modifier type ID . LPAREN params RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 122


state 97

    (19) method_decl -> access_modifier STATIC type . ID LPAREN params RPAREN LBRACE body RBRACE
    (32) type -> type . LSQUARE RSQUARE

    ID              shift and go to state 123
    LSQUARE         shift and go to state 26


state 98

    (56) statement -> IF LPAREN expr . RPAREN statement ELSE statement
    (57) statement -> IF LPAREN expr . RPAREN statement
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term

    RPAREN          shift and go to state 124
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 99

    (58) statement -> WHILE LPAREN expr . RPAREN statement
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term

    RPAREN          shift and go to state 125
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 100

    (59) statement -> SYSTEM DOT OUT . DOT PRINTLN LPAREN expr RPAREN SEMICOLON

    DOT             shift and go to state 126


state 101

    (8) class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE . body RBRACE
    (23) body -> . var_decl body
    (24) body -> . method_decl body
    (25) body -> . statement body
    (26) body -> . empty
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (16) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (17) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (19) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (62) empty -> .
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 35
    RBRACE          reduce using rule 62 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14

    access_modifier                shift and go to state 43
    body                           shift and go to state 127
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    type                           shift and go to state 42

state 102

    (9) class_decl -> access_modifier CLASS ID LBRACE body RBRACE .

    CLASS           reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    IMPORT          reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    PUBLIC          reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    PRIVATE         reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    PROTECTED       reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    INT             reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    STRING          reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    ID              reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    VOID            reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)
    $end            reduce using rule 9 (class_decl -> access_modifier CLASS ID LBRACE body RBRACE .)


state 103

    (45) factor -> ID LSQUARE expr . RSQUARE
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term

    RSQUARE         shift and go to state 128
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 104

    (46) factor -> ID DOT ID .
    (47) factor -> ID DOT ID . LPAREN args RPAREN

    TIMES           reduce using rule 46 (factor -> ID DOT ID .)
    DIVIDE          reduce using rule 46 (factor -> ID DOT ID .)
    SEMICOLON       reduce using rule 46 (factor -> ID DOT ID .)
    PLUS            reduce using rule 46 (factor -> ID DOT ID .)
    MINUS           reduce using rule 46 (factor -> ID DOT ID .)
    RPAREN          reduce using rule 46 (factor -> ID DOT ID .)
    RSQUARE         reduce using rule 46 (factor -> ID DOT ID .)
    COMMA           reduce using rule 46 (factor -> ID DOT ID .)
    LPAREN          shift and go to state 129


state 105

    (48) factor -> ID LPAREN args . RPAREN

    RPAREN          shift and go to state 130


state 106

    (52) args -> expr .
    (53) args -> expr . COMMA args
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term

    RPAREN          reduce using rule 52 (args -> expr .)
    COMMA           shift and go to state 131
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 107

    (54) args -> empty .

    RPAREN          reduce using rule 54 (args -> empty .)


state 108

    (33) expr -> expr PLUS term .
    (36) term -> term . TIMES factor
    (37) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 33 (expr -> expr PLUS term .)
    PLUS            reduce using rule 33 (expr -> expr PLUS term .)
    MINUS           reduce using rule 33 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 33 (expr -> expr PLUS term .)
    RSQUARE         reduce using rule 33 (expr -> expr PLUS term .)
    COMMA           reduce using rule 33 (expr -> expr PLUS term .)
    TIMES           shift and go to state 84
    DIVIDE          shift and go to state 85


state 109

    (34) expr -> expr MINUS term .
    (36) term -> term . TIMES factor
    (37) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 34 (expr -> expr MINUS term .)
    PLUS            reduce using rule 34 (expr -> expr MINUS term .)
    MINUS           reduce using rule 34 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 34 (expr -> expr MINUS term .)
    RSQUARE         reduce using rule 34 (expr -> expr MINUS term .)
    COMMA           reduce using rule 34 (expr -> expr MINUS term .)
    TIMES           shift and go to state 84
    DIVIDE          shift and go to state 85


state 110

    (36) term -> term TIMES factor .

    TIMES           reduce using rule 36 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 36 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 36 (term -> term TIMES factor .)
    PLUS            reduce using rule 36 (term -> term TIMES factor .)
    MINUS           reduce using rule 36 (term -> term TIMES factor .)
    RPAREN          reduce using rule 36 (term -> term TIMES factor .)
    RSQUARE         reduce using rule 36 (term -> term TIMES factor .)
    COMMA           reduce using rule 36 (term -> term TIMES factor .)


state 111

    (37) term -> term DIVIDE factor .

    TIMES           reduce using rule 37 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 37 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 37 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 37 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 37 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 37 (term -> term DIVIDE factor .)
    RSQUARE         reduce using rule 37 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 37 (term -> term DIVIDE factor .)


state 112

    (51) factor -> LPAREN expr RPAREN .

    TIMES           reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    RSQUARE         reduce using rule 51 (factor -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 51 (factor -> LPAREN expr RPAREN .)


state 113

    (49) factor -> NEW ID LPAREN . RPAREN

    RPAREN          shift and go to state 132


state 114

    (50) factor -> NEW INT LSQUARE . expr RSQUARE
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . term
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    expr                           shift and go to state 133
    term                           shift and go to state 52
    factor                         shift and go to state 54

state 115

    (6) class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .

    CLASS           reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    IMPORT          reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    PUBLIC          reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    PRIVATE         reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    PROTECTED       reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    INT             reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    STRING          reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    ID              reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    VOID            reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)
    $end            reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE body RBRACE .)


state 116

    (60) statement -> ID EQUALS expr SEMICOLON .

    LBRACE          reduce using rule 60 (statement -> ID EQUALS expr SEMICOLON .)
    IF              reduce using rule 60 (statement -> ID EQUALS expr SEMICOLON .)
    WHILE           reduce using rule 60 (statement -> ID EQUALS expr SEMICOLON .)
    SYSTEM          reduce using rule 60 (statement -> ID EQUALS expr SEMICOLON .)
    ID              reduce using rule 60 (statement -> ID EQUALS expr SEMICOLON .)
    INT             reduce using rule 60 (statement -> ID EQUALS expr SEMICOLON .)
    BOOLEAN         reduce using rule 60 (statement -> ID EQUALS expr SEMICOLON .)
    STRING          reduce using rule 60 (statement -> ID EQUALS expr SEMICOLON .)
    VOID            reduce using rule 60 (statement -> ID EQUALS expr SEMICOLON .)
    PUBLIC          reduce using rule 60 (statement -> ID EQUALS expr SEMICOLON .)
    PRIVATE         reduce using rule 60 (statement -> ID EQUALS expr SEMICOLON .)
    PROTECTED       reduce using rule 60 (statement -> ID EQUALS expr SEMICOLON .)
    RBRACE          reduce using rule 60 (statement -> ID EQUALS expr SEMICOLON .)
    ELSE            reduce using rule 60 (statement -> ID EQUALS expr SEMICOLON .)


state 117

    (61) statement -> ID LSQUARE expr RSQUARE . EQUALS expr SEMICOLON

    EQUALS          shift and go to state 134


state 118

    (20) params -> type . ID
    (21) params -> type . ID COMMA params
    (32) type -> type . LSQUARE RSQUARE

    ID              shift and go to state 135
    LSQUARE         shift and go to state 26


state 119

    (16) method_decl -> type ID LPAREN params . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 136


state 120

    (18) method_decl -> type ID LPAREN RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 137


state 121

    (22) params -> empty .

    RPAREN          reduce using rule 22 (params -> empty .)


state 122

    (17) method_decl -> access_modifier type ID LPAREN . params RPAREN LBRACE body RBRACE
    (20) params -> . type ID
    (21) params -> . type ID COMMA params
    (22) params -> . empty
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (62) empty -> .

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18
    RPAREN          reduce using rule 62 (empty -> .)

    type                           shift and go to state 118
    params                         shift and go to state 138
    empty                          shift and go to state 121

state 123

    (19) method_decl -> access_modifier STATIC type ID . LPAREN params RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 139


state 124

    (56) statement -> IF LPAREN expr RPAREN . statement ELSE statement
    (57) statement -> IF LPAREN expr RPAREN . statement
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 141

    statement                      shift and go to state 140

state 125

    (58) statement -> WHILE LPAREN expr RPAREN . statement
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 141

    statement                      shift and go to state 142

state 126

    (59) statement -> SYSTEM DOT OUT DOT . PRINTLN LPAREN expr RPAREN SEMICOLON

    PRINTLN         shift and go to state 143


state 127

    (8) class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body . RBRACE

    RBRACE          shift and go to state 144


state 128

    (45) factor -> ID LSQUARE expr RSQUARE .

    TIMES           reduce using rule 45 (factor -> ID LSQUARE expr RSQUARE .)
    DIVIDE          reduce using rule 45 (factor -> ID LSQUARE expr RSQUARE .)
    SEMICOLON       reduce using rule 45 (factor -> ID LSQUARE expr RSQUARE .)
    PLUS            reduce using rule 45 (factor -> ID LSQUARE expr RSQUARE .)
    MINUS           reduce using rule 45 (factor -> ID LSQUARE expr RSQUARE .)
    RPAREN          reduce using rule 45 (factor -> ID LSQUARE expr RSQUARE .)
    RSQUARE         reduce using rule 45 (factor -> ID LSQUARE expr RSQUARE .)
    COMMA           reduce using rule 45 (factor -> ID LSQUARE expr RSQUARE .)


state 129

    (47) factor -> ID DOT ID LPAREN . args RPAREN
    (52) args -> . expr
    (53) args -> . expr COMMA args
    (54) args -> . empty
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . term
    (62) empty -> .
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    RPAREN          reduce using rule 62 (empty -> .)
    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    args                           shift and go to state 145
    expr                           shift and go to state 106
    empty                          shift and go to state 107
    term                           shift and go to state 52
    factor                         shift and go to state 54

state 130

    (48) factor -> ID LPAREN args RPAREN .

    TIMES           reduce using rule 48 (factor -> ID LPAREN args RPAREN .)
    DIVIDE          reduce using rule 48 (factor -> ID LPAREN args RPAREN .)
    SEMICOLON       reduce using rule 48 (factor -> ID LPAREN args RPAREN .)
    PLUS            reduce using rule 48 (factor -> ID LPAREN args RPAREN .)
    MINUS           reduce using rule 48 (factor -> ID LPAREN args RPAREN .)
    RPAREN          reduce using rule 48 (factor -> ID LPAREN args RPAREN .)
    RSQUARE         reduce using rule 48 (factor -> ID LPAREN args RPAREN .)
    COMMA           reduce using rule 48 (factor -> ID LPAREN args RPAREN .)


state 131

    (53) args -> expr COMMA . args
    (52) args -> . expr
    (53) args -> . expr COMMA args
    (54) args -> . empty
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . term
    (62) empty -> .
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    RPAREN          reduce using rule 62 (empty -> .)
    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    expr                           shift and go to state 106
    args                           shift and go to state 146
    empty                          shift and go to state 107
    term                           shift and go to state 52
    factor                         shift and go to state 54

state 132

    (49) factor -> NEW ID LPAREN RPAREN .

    TIMES           reduce using rule 49 (factor -> NEW ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 49 (factor -> NEW ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 49 (factor -> NEW ID LPAREN RPAREN .)
    PLUS            reduce using rule 49 (factor -> NEW ID LPAREN RPAREN .)
    MINUS           reduce using rule 49 (factor -> NEW ID LPAREN RPAREN .)
    RPAREN          reduce using rule 49 (factor -> NEW ID LPAREN RPAREN .)
    RSQUARE         reduce using rule 49 (factor -> NEW ID LPAREN RPAREN .)
    COMMA           reduce using rule 49 (factor -> NEW ID LPAREN RPAREN .)


state 133

    (50) factor -> NEW INT LSQUARE expr . RSQUARE
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term

    RSQUARE         shift and go to state 147
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 134

    (61) statement -> ID LSQUARE expr RSQUARE EQUALS . expr SEMICOLON
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . term
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    expr                           shift and go to state 148
    term                           shift and go to state 52
    factor                         shift and go to state 54

state 135

    (20) params -> type ID .
    (21) params -> type ID . COMMA params

    RPAREN          reduce using rule 20 (params -> type ID .)
    COMMA           shift and go to state 149


state 136

    (16) method_decl -> type ID LPAREN params RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 150


state 137

    (18) method_decl -> type ID LPAREN RPAREN LBRACE . body RBRACE
    (23) body -> . var_decl body
    (24) body -> . method_decl body
    (25) body -> . statement body
    (26) body -> . empty
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (16) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (17) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (19) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (62) empty -> .
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 35
    RBRACE          reduce using rule 62 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14

    type                           shift and go to state 42
    body                           shift and go to state 151
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    access_modifier                shift and go to state 43

state 138

    (17) method_decl -> access_modifier type ID LPAREN params . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 152


state 139

    (19) method_decl -> access_modifier STATIC type ID LPAREN . params RPAREN LBRACE body RBRACE
    (20) params -> . type ID
    (21) params -> . type ID COMMA params
    (22) params -> . empty
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (62) empty -> .

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18
    RPAREN          reduce using rule 62 (empty -> .)

    type                           shift and go to state 118
    params                         shift and go to state 153
    empty                          shift and go to state 121

state 140

    (56) statement -> IF LPAREN expr RPAREN statement . ELSE statement
    (57) statement -> IF LPAREN expr RPAREN statement .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 154
    LBRACE          reduce using rule 57 (statement -> IF LPAREN expr RPAREN statement .)
    IF              reduce using rule 57 (statement -> IF LPAREN expr RPAREN statement .)
    WHILE           reduce using rule 57 (statement -> IF LPAREN expr RPAREN statement .)
    SYSTEM          reduce using rule 57 (statement -> IF LPAREN expr RPAREN statement .)
    ID              reduce using rule 57 (statement -> IF LPAREN expr RPAREN statement .)
    INT             reduce using rule 57 (statement -> IF LPAREN expr RPAREN statement .)
    BOOLEAN         reduce using rule 57 (statement -> IF LPAREN expr RPAREN statement .)
    STRING          reduce using rule 57 (statement -> IF LPAREN expr RPAREN statement .)
    VOID            reduce using rule 57 (statement -> IF LPAREN expr RPAREN statement .)
    PUBLIC          reduce using rule 57 (statement -> IF LPAREN expr RPAREN statement .)
    PRIVATE         reduce using rule 57 (statement -> IF LPAREN expr RPAREN statement .)
    PROTECTED       reduce using rule 57 (statement -> IF LPAREN expr RPAREN statement .)
    RBRACE          reduce using rule 57 (statement -> IF LPAREN expr RPAREN statement .)

  ! ELSE            [ reduce using rule 57 (statement -> IF LPAREN expr RPAREN statement .) ]


state 141

    (60) statement -> ID . EQUALS expr SEMICOLON
    (61) statement -> ID . LSQUARE expr RSQUARE EQUALS expr SEMICOLON

    EQUALS          shift and go to state 62
    LSQUARE         shift and go to state 63


state 142

    (58) statement -> WHILE LPAREN expr RPAREN statement .

    LBRACE          reduce using rule 58 (statement -> WHILE LPAREN expr RPAREN statement .)
    IF              reduce using rule 58 (statement -> WHILE LPAREN expr RPAREN statement .)
    WHILE           reduce using rule 58 (statement -> WHILE LPAREN expr RPAREN statement .)
    SYSTEM          reduce using rule 58 (statement -> WHILE LPAREN expr RPAREN statement .)
    ID              reduce using rule 58 (statement -> WHILE LPAREN expr RPAREN statement .)
    INT             reduce using rule 58 (statement -> WHILE LPAREN expr RPAREN statement .)
    BOOLEAN         reduce using rule 58 (statement -> WHILE LPAREN expr RPAREN statement .)
    STRING          reduce using rule 58 (statement -> WHILE LPAREN expr RPAREN statement .)
    VOID            reduce using rule 58 (statement -> WHILE LPAREN expr RPAREN statement .)
    PUBLIC          reduce using rule 58 (statement -> WHILE LPAREN expr RPAREN statement .)
    PRIVATE         reduce using rule 58 (statement -> WHILE LPAREN expr RPAREN statement .)
    PROTECTED       reduce using rule 58 (statement -> WHILE LPAREN expr RPAREN statement .)
    RBRACE          reduce using rule 58 (statement -> WHILE LPAREN expr RPAREN statement .)
    ELSE            reduce using rule 58 (statement -> WHILE LPAREN expr RPAREN statement .)


state 143

    (59) statement -> SYSTEM DOT OUT DOT PRINTLN . LPAREN expr RPAREN SEMICOLON

    LPAREN          shift and go to state 155


state 144

    (8) class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .

    CLASS           reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    IMPORT          reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    PUBLIC          reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    PRIVATE         reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    PROTECTED       reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    INT             reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    STRING          reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    ID              reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    VOID            reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)
    $end            reduce using rule 8 (class_decl -> access_modifier CLASS ID EXTENDS ID LBRACE body RBRACE .)


state 145

    (47) factor -> ID DOT ID LPAREN args . RPAREN

    RPAREN          shift and go to state 156


state 146

    (53) args -> expr COMMA args .

    RPAREN          reduce using rule 53 (args -> expr COMMA args .)


state 147

    (50) factor -> NEW INT LSQUARE expr RSQUARE .

    TIMES           reduce using rule 50 (factor -> NEW INT LSQUARE expr RSQUARE .)
    DIVIDE          reduce using rule 50 (factor -> NEW INT LSQUARE expr RSQUARE .)
    SEMICOLON       reduce using rule 50 (factor -> NEW INT LSQUARE expr RSQUARE .)
    PLUS            reduce using rule 50 (factor -> NEW INT LSQUARE expr RSQUARE .)
    MINUS           reduce using rule 50 (factor -> NEW INT LSQUARE expr RSQUARE .)
    RPAREN          reduce using rule 50 (factor -> NEW INT LSQUARE expr RSQUARE .)
    RSQUARE         reduce using rule 50 (factor -> NEW INT LSQUARE expr RSQUARE .)
    COMMA           reduce using rule 50 (factor -> NEW INT LSQUARE expr RSQUARE .)


state 148

    (61) statement -> ID LSQUARE expr RSQUARE EQUALS expr . SEMICOLON
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 157
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 149

    (21) params -> type ID COMMA . params
    (20) params -> . type ID
    (21) params -> . type ID COMMA params
    (22) params -> . empty
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (62) empty -> .

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    ID              shift and go to state 8
    VOID            shift and go to state 18
    RPAREN          reduce using rule 62 (empty -> .)

    type                           shift and go to state 118
    params                         shift and go to state 158
    empty                          shift and go to state 121

state 150

    (16) method_decl -> type ID LPAREN params RPAREN LBRACE . body RBRACE
    (23) body -> . var_decl body
    (24) body -> . method_decl body
    (25) body -> . statement body
    (26) body -> . empty
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (16) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (17) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (19) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (62) empty -> .
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 35
    RBRACE          reduce using rule 62 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14

    type                           shift and go to state 42
    body                           shift and go to state 159
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41
    access_modifier                shift and go to state 43

state 151

    (18) method_decl -> type ID LPAREN RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 160


state 152

    (17) method_decl -> access_modifier type ID LPAREN params RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 161


state 153

    (19) method_decl -> access_modifier STATIC type ID LPAREN params . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 162


state 154

    (56) statement -> IF LPAREN expr RPAREN statement ELSE . statement
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 141

    statement                      shift and go to state 163

state 155

    (59) statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN . expr RPAREN SEMICOLON
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . term
    (36) term -> . term TIMES factor
    (37) term -> . term DIVIDE factor
    (38) term -> . factor
    (39) factor -> . MINUS factor
    (40) factor -> . NOT factor
    (41) factor -> . INT_LITERAL
    (42) factor -> . BOOLEAN_LITERAL
    (43) factor -> . STRING_LITERAL
    (44) factor -> . ID
    (45) factor -> . ID LSQUARE expr RSQUARE
    (46) factor -> . ID DOT ID
    (47) factor -> . ID DOT ID LPAREN args RPAREN
    (48) factor -> . ID LPAREN args RPAREN
    (49) factor -> . NEW ID LPAREN RPAREN
    (50) factor -> . NEW INT LSQUARE expr RSQUARE
    (51) factor -> . LPAREN expr RPAREN

    MINUS           shift and go to state 53
    NOT             shift and go to state 55
    INT_LITERAL     shift and go to state 56
    BOOLEAN_LITERAL shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    ID              shift and go to state 50
    NEW             shift and go to state 60
    LPAREN          shift and go to state 59

    expr                           shift and go to state 164
    term                           shift and go to state 52
    factor                         shift and go to state 54

state 156

    (47) factor -> ID DOT ID LPAREN args RPAREN .

    TIMES           reduce using rule 47 (factor -> ID DOT ID LPAREN args RPAREN .)
    DIVIDE          reduce using rule 47 (factor -> ID DOT ID LPAREN args RPAREN .)
    SEMICOLON       reduce using rule 47 (factor -> ID DOT ID LPAREN args RPAREN .)
    PLUS            reduce using rule 47 (factor -> ID DOT ID LPAREN args RPAREN .)
    MINUS           reduce using rule 47 (factor -> ID DOT ID LPAREN args RPAREN .)
    RPAREN          reduce using rule 47 (factor -> ID DOT ID LPAREN args RPAREN .)
    RSQUARE         reduce using rule 47 (factor -> ID DOT ID LPAREN args RPAREN .)
    COMMA           reduce using rule 47 (factor -> ID DOT ID LPAREN args RPAREN .)


state 157

    (61) statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .

    LBRACE          reduce using rule 61 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    IF              reduce using rule 61 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    WHILE           reduce using rule 61 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    SYSTEM          reduce using rule 61 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    ID              reduce using rule 61 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    INT             reduce using rule 61 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    BOOLEAN         reduce using rule 61 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    STRING          reduce using rule 61 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    VOID            reduce using rule 61 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    PUBLIC          reduce using rule 61 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    PRIVATE         reduce using rule 61 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    PROTECTED       reduce using rule 61 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    RBRACE          reduce using rule 61 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)
    ELSE            reduce using rule 61 (statement -> ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON .)


state 158

    (21) params -> type ID COMMA params .

    RPAREN          reduce using rule 21 (params -> type ID COMMA params .)


state 159

    (16) method_decl -> type ID LPAREN params RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 165


state 160

    (18) method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .

    LBRACE          reduce using rule 18 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 18 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 18 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    SYSTEM          reduce using rule 18 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 18 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 18 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 18 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 18 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    VOID            reduce using rule 18 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    PUBLIC          reduce using rule 18 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    PRIVATE         reduce using rule 18 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    PROTECTED       reduce using rule 18 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 18 (method_decl -> type ID LPAREN RPAREN LBRACE body RBRACE .)


state 161

    (17) method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE . body RBRACE
    (23) body -> . var_decl body
    (24) body -> . method_decl body
    (25) body -> . statement body
    (26) body -> . empty
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (16) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (17) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (19) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (62) empty -> .
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 35
    RBRACE          reduce using rule 62 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14

    access_modifier                shift and go to state 43
    type                           shift and go to state 42
    body                           shift and go to state 166
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41

state 162

    (19) method_decl -> access_modifier STATIC type ID LPAREN params RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 167


state 163

    (56) statement -> IF LPAREN expr RPAREN statement ELSE statement .

    LBRACE          reduce using rule 56 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    IF              reduce using rule 56 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    WHILE           reduce using rule 56 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    SYSTEM          reduce using rule 56 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    ID              reduce using rule 56 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    INT             reduce using rule 56 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    BOOLEAN         reduce using rule 56 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    STRING          reduce using rule 56 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    VOID            reduce using rule 56 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    PUBLIC          reduce using rule 56 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    PRIVATE         reduce using rule 56 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    PROTECTED       reduce using rule 56 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    RBRACE          reduce using rule 56 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    ELSE            reduce using rule 56 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)


state 164

    (59) statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr . RPAREN SEMICOLON
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term

    RPAREN          shift and go to state 168
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 165

    (16) method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .

    LBRACE          reduce using rule 16 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 16 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 16 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    SYSTEM          reduce using rule 16 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 16 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 16 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 16 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 16 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    VOID            reduce using rule 16 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PUBLIC          reduce using rule 16 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PRIVATE         reduce using rule 16 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PROTECTED       reduce using rule 16 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 16 (method_decl -> type ID LPAREN params RPAREN LBRACE body RBRACE .)


state 166

    (17) method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 169


state 167

    (19) method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE . body RBRACE
    (23) body -> . var_decl body
    (24) body -> . method_decl body
    (25) body -> . statement body
    (26) body -> . empty
    (14) var_decl -> . type ID SEMICOLON
    (15) var_decl -> . type ID EQUAL expr SEMICOLON
    (16) method_decl -> . type ID LPAREN params RPAREN LBRACE body RBRACE
    (17) method_decl -> . access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE
    (18) method_decl -> . type ID LPAREN RPAREN LBRACE body RBRACE
    (19) method_decl -> . access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE
    (55) statement -> . LBRACE body RBRACE
    (56) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (57) statement -> . IF LPAREN expr RPAREN statement
    (58) statement -> . WHILE LPAREN expr RPAREN statement
    (59) statement -> . SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON
    (60) statement -> . ID EQUALS expr SEMICOLON
    (61) statement -> . ID LSQUARE expr RSQUARE EQUALS expr SEMICOLON
    (62) empty -> .
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . STRING
    (30) type -> . ID
    (31) type -> . VOID
    (32) type -> . type LSQUARE RSQUARE
    (10) access_modifier -> . PUBLIC
    (11) access_modifier -> . PRIVATE
    (12) access_modifier -> . PROTECTED

    LBRACE          shift and go to state 36
    IF              shift and go to state 44
    WHILE           shift and go to state 45
    SYSTEM          shift and go to state 46
    ID              shift and go to state 35
    RBRACE          reduce using rule 62 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 16
    STRING          shift and go to state 17
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    PROTECTED       shift and go to state 14

    access_modifier                shift and go to state 43
    type                           shift and go to state 42
    body                           shift and go to state 170
    var_decl                       shift and go to state 38
    method_decl                    shift and go to state 39
    statement                      shift and go to state 40
    empty                          shift and go to state 41

state 168

    (59) statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 171


state 169

    (17) method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .

    LBRACE          reduce using rule 17 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 17 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 17 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    SYSTEM          reduce using rule 17 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 17 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 17 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 17 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 17 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    VOID            reduce using rule 17 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PUBLIC          reduce using rule 17 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PRIVATE         reduce using rule 17 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PROTECTED       reduce using rule 17 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 17 (method_decl -> access_modifier type ID LPAREN params RPAREN LBRACE body RBRACE .)


state 170

    (19) method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 172


state 171

    (59) statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .

    LBRACE          reduce using rule 59 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    IF              reduce using rule 59 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    WHILE           reduce using rule 59 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    SYSTEM          reduce using rule 59 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    ID              reduce using rule 59 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    INT             reduce using rule 59 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 59 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    STRING          reduce using rule 59 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    VOID            reduce using rule 59 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    PUBLIC          reduce using rule 59 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    PRIVATE         reduce using rule 59 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    PROTECTED       reduce using rule 59 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    RBRACE          reduce using rule 59 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)
    ELSE            reduce using rule 59 (statement -> SYSTEM DOT OUT DOT PRINTLN LPAREN expr RPAREN SEMICOLON .)


state 172

    (19) method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .

    LBRACE          reduce using rule 19 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 19 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 19 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    SYSTEM          reduce using rule 19 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 19 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 19 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 19 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 19 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    VOID            reduce using rule 19 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PUBLIC          reduce using rule 19 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PRIVATE         reduce using rule 19 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    PROTECTED       reduce using rule 19 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 19 (method_decl -> access_modifier STATIC type ID LPAREN params RPAREN LBRACE body RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LSQUARE in state 35 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 95 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 140 resolved as shift
